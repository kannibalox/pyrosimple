{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyrosimple","text":"<p>Welcome to pyrosimple, a collection of tools for working with rTorrent. With pyrosimple, you can do everything ranging from making low-level RPC calls, to running a full-fledged daemon that will manage rTorrent according to user-defined rules.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyrosimple\n# pip install 'pyrosimple[torque]' # Optional dependencies, for advanced features\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>See the Quick Start for getting pyrosimple up and running quickly.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>All programs stand on the shoulders of giants, and the giant for this one is the great pyrocore toolset. Much of the code has been refactored, but the base structure and concepts are the same.</p>"},{"location":"advanced/","title":"Advanced Features","text":"<p>Note</p> <p>Using these features requires some knowledge in the area of Linux, Bash, and Python, but they enable you to customize your setup even further and handle very specific use-cases.</p>"},{"location":"advanced/#advanced-rtcontrol","title":"Advanced 'rtcontrol'","text":""},{"location":"advanced/#executing-os-commands","title":"Executing OS commands","text":"<p>The <code>--call</code> and <code>--spawn</code> options can be used to call an OS level command and feed it with data from the selected items. The argument to both options is a template, i.e. you can have things like <code>{{d.hash}}</code> in them.</p> <p>When using <code>--call</code>, the command is passed to the shell for parsing -- with obvious implications regarding the quoting of arguments, thus <code>--call</code> only makes sense if you need I/O redirection or similar shell features.</p> <p>In contrast, the <code>--spawn</code> option splits its argument list according to shell rules before expanding the template placeholders, and then calls the resulting sequence of command name and arguments directly. Consider <code>--spawn 'echo \"name: {{d.name}}\"'</code> vs. <code>--spawn 'echo name: {{d.name}}'</code> -- the first form passes one argument to <code>/bin/echo</code>, the second form two arguments. Note that in both cases, spaces or shell meta characters contained in the item name are of no relevance, since the argument list is split according to the template, not its expanded value.</p> <p>To list all the fields available in the first five items, try this command:</p> <pre><code>rtcontrol // -/5 --spawn \"echo -e '\\\\n'{{i}}\" | sed -re 's/, /,\\n    /g'\n</code></pre> <p>Unlike <code>--call</code>, where you can use shell syntax to call several commands, <code>--spawn</code> can be passed several times for executing a sequence of commands. If any called command fails, the <code>rtcontrol</code> call is aborted with an error.</p>"},{"location":"advanced/#copy-session-metafiles-by-category","title":"Copy Session Metafiles by Category","text":"<p>Here's a practical example for using <code>--spawn</code>, it copies all your loaded metafiles from the session directory into a folder structure categorized by the ruTorrent label. Unlabelled items go to the <code>_NOLABEL</code> folder.</p> <pre><code>target=\"/tmp/metafiles\"\nrm -rf \"$target\"\nrtcontrol // \\\n--spawn 'mkdir -p \"'\"$target/\"'\"'{{d.label or \"_NOLABEL\" | shell}}' \\\n  --spawn 'cp {{d.sessionfile}} \"'\"$target\"'\"/{{d.label or \"_NOLABEL\" | shell}}/{{d.name|shell}}-{{d.hash[:7]}}.torrent'\n</code></pre> <p>The copied metafiles themselves are renamed to the contained name of the item's data, plus a small part of the infohash to make these names unique.</p> <p>Replace the <code>d.label</code> by <code>d.\u2039fieldname\u203a</code> to categorize by other values, e.g. <code>d.alias</code> for 'by tracker'.</p>"},{"location":"advanced/#executing-xmlrpc-commands-rtcontrol-exec","title":"Executing XMLRPC commands {#rtcontrol-exec}","text":"<p>If you want to apply some custom XMLRPC commands against a set of download items, the <code>--exec</code> option of <code>rtcontrol</code> allows you to do that. For global commands not referring to specific items, see the next section about the <code>rtxmlrpc</code> tool. Read through the following examples to understand how <code>--exec</code> works, features are explained as they are used there. Also make sure you understand basic things like <code>output-templates</code>{.interpreted-text role=\"ref\"} beforehand, it's assumed here that you do.</p>"},{"location":"advanced/#repairing-stuck-items","title":"Repairing Stuck Items","text":"<p>Let's start with an easy example of using <code>--exec</code>, where no templating is needed:</p> <pre><code>rtcontrol --exec 'd.stop= ; d.close= ; f.multicall=,f.set_create_queued=0,f.set_resize_queued=0 ; d.check_hash=' \\\n--from stopped // -/1\n</code></pre> <p>This command simulates pressing <code>^K^E^R</code> in the curses UI (which cleans the state of stuck / damaged items), and as written above only affects the first stopped item.</p> <p>Use different filter arguments after <code>--exec</code> to select other items. Afterwards, use <code>--start</code> to start these items again.</p>"},{"location":"advanced/#manually-triggering-events","title":"Manually Triggering Events","text":"<p>Since rTorrent events are merely multi-call commands, you can trigger them manually by calling them on selected items. This calls <code>event.download.finished</code> (again) on complete items loaded in the last 10 minutes:</p> <pre><code>rtcontrol --exec \"event.download.finished=\" 'loaded&lt;10m' is_complete=y\n</code></pre> <p>Make sure that the registered handlers do not have adverse effects when called repeatedly, i.e. know what you're doing. The handlers for an event can be listed like so:</p> <pre><code>rtxmlrpc --output-format repr method.get '' event.download.finished\n</code></pre>"},{"location":"advanced/#relocating-download-data","title":"Relocating Download Data","text":"<p>The most simple variant of changing the download path is setting a new fixed location for all selected items, as follows:</p> <pre><code>rtcontrol --exec 'd.directory_base.set=\"/mnt/data/new/path\"' directory=/mnt/data/old/path\n</code></pre> <p>This replaces the location of items stored at <code>/mnt/data/old/path</code> with a new path. But to be really useful, we'd want to shift any path under a given base directory to a new location -- the next command does this by using templating and calculating the new path based on the old one:</p> <pre><code>rtcontrol \\\n--exec 'd.directory_base.set=\"{{item.directory|subst(\"^/mnt/data/\",\"/var/data/\")}}\" ; &gt;d.directory=' \\\npath=/mnt/data/\\*\n</code></pre> <p>This selects any item stored under <code>/mnt/data</code> and relocates it to the new base directory <code>/var/data</code>. Fields of an item can be used via a <code>item.\u2039field-name\u203a</code> reference. Adding <code>&gt;d.directory=</code> prints the new location to the console -- a semicolon with spaces on both sides delimits several commands, and the <code>&gt;</code> prints the result of a XMLRPC command.</p> <p>The <code>move-data</code>{.interpreted-text role=\"ref\"} section has more on how to also move the data on disk, in addition to changing the location in rTorrent's session as shown here.</p>"},{"location":"advanced/#making-shared-data-paths-unique","title":"Making Shared Data Paths Unique","text":"<p>Another example regarding data paths is this:</p> <pre><code>rtcontrol --from stopped // --exec 'directory.set={{item.directory}}-{{item.hash}}'\n</code></pre> <p>That command ensures that items that would download into the same path get a unique name by appending the info hash, and assumes those items weren't started yet (i.e. added via <code>load.normal</code>).</p>"},{"location":"advanced/#changing-announce-urls-in-bulk","title":"Changing Announce URLs in Bulk","text":"<p>The next example replaces an active announce URL with a new one, which is necessary after a domain or passkey change. Compared to other methods like using <code>sed</code> on the files in your session directory, this does not require a client restart, and is also safer (the <code>sed</code> approach can easily make your session files unusable). This disables all old announce URLs in group 0 using a <code>t.multicall</code>, and then adds a new one:</p> <pre><code>rtcontrol \\\n--exec 't.multicall=0,t.disable= ; d.tracker.insert=0,\"http://new.example.com/announce\" ; d.save_full_session=' \\\n\"tracker=http://old.example.com/announce\"\n</code></pre> <p>The <code>tracker.insert</code> also shows that arguments to commands can be quoted.</p>"},{"location":"advanced/#using-templates-as-filter-values","title":"Using Templates as Filter Values","text":"<p>As mentioned in <code>filter-conditions</code>, you can compare a string field to a template. This can be a brain twister, so just look at the following example, which replaces any download path in an item by the real storage path, but only if they differ.</p> <pre><code># List any differences\nrtcontrol path='*' is_multi_file=y 'directory!={{d.realpath|replace(\"[\",\"[[]\")}}' \\\n-qo directory,realpath\nrtcontrol path='*' is_multi_file=n 'directory!={{d.realpath|pathdir|replace(\"[\",\"[[]\")}}' \\\n-qo directory,realpath.pathdir\n\n# Fix any differences (i.e. resolve all symlinks for good)\nrtcontrol path='*' is_multi_file=y 'directory!={{d.realpath|replace(\"[\",\"[[]\")}}' \\\n--exec 'directory_base.set={{item.realpath}}'\nrtcontrol path='*' is_multi_file=n 'directory!={{d.realpath|pathdir|replace(\"[\",\"[[]\")}}' \\\n--exec 'directory.set={{item.realpath|pathdir}}'\n</code></pre> <p>As so often, 'multi' and 'single' items need a slightly different treatment.</p> <p>Note that <code>[</code> characters are escaped to <code>[[]</code>, so that things like <code>[2017]</code> in a filename do not lead to unexpected results. <code>*</code> and <code>?</code> though are kept intact and are used for glob matching as normal, because they match their own literal form if they appear in the field value (on the right-hand side).</p>"},{"location":"advanced/#using-rtxmlrpc","title":"Using 'rtxmlrpc'","text":""},{"location":"advanced/#load-metafile-with-a-specific-data-path","title":"Load Metafile with a Specific Data Path","text":"<p>The following shows how to load a metafile from any path in <code>$metafile</code>, not only a watch directory, with the data downloaded to <code>$data_dir</code> by adding a <code>d.directory_base.set</code> on-load command. You might need to change that to <code>d.directory.set</code> depending on your exact use-case.</p> <pre><code>rtxmlrpc -q load.normal '' \"$metafile\" \\\n\"d.directory_base.set=\\\"$data_dir\\\"\" \"d.priority.set=1\"\n</code></pre> <p>Use <code>load.start</code> to start that item immediately. If the metafile has fast-resume information and the data is already there, no extra hashing is done.</p> <p>And just to show you can add more on-load commands, the priority of the new item is set to <code>low</code>. Other common on-load commands are those that set custom values, e.g. the ruTorrent label.</p>"},{"location":"advanced/#general-maintenance-tasks","title":"General maintenance tasks","text":"<p>Here are some commands that can help with managing your rTorrent instance:</p> <pre><code># Flush ALL session data NOW, use this before you make a backup of your session directory\nrtxmlrpc session.save\n</code></pre>"},{"location":"advanced/#setting-and-checking-throttles","title":"Setting and checking throttles","text":"<p>To set the speed of the <code>slow</code> throttle, and then check your new limit and print the current download rate, use:</p> <pre><code>$ rtxmlrpc throttle.down '' slow 120\n0\n$ rtxmlrpc throttle.down.max '' slow\n122880\n$ rtxmlrpc throttle.down.rate '' slow\n0\n</code></pre> <p>Note that the speed is specified in KiB/s as a string when setting it but returned in bytes/s as an integer on queries.</p> <p>The following script makes this available in an easy usable form, e.g. <code>throttle slow 42</code> -- it also shows the current rate and settings of all defined throttles when called without arguments:</p> <pre><code>#! /bin/bash\n# Set speed of named throttle\n#\n# CONFIGURATION\n#\nthrottle_name=\"seed\" # default name\nunit=1024 # KiB/s\n#\n# HERE BE DRAGONS!\n#\ndown=false\nif test \"$1\" = \"-d\"; then\ndown=true\nshift\nfi\nif test -n \"$(echo $1 | tr -d 0-9)\"; then\n# Non-numeric $1 is a name\nthrottle_name=$1\nshift\nfi\nif test -z \"$1\"; then\necho &gt;&amp;2 \"Usage: ${0/$HOME/~} [-d] [&lt;throttle-name=$throttle_name&gt;] &lt;rate&gt;\"\nrtorrent_rc=~/.rtorrent.rc\n    test -e \"$rtorrent_rc\" || rtorrent_rc=\"$(rtxmlrpc system.get_cwd)/rtorrent.rc\"\nif test -e \"$rtorrent_rc\"; then\nthrottles=\"$(egrep '^throttle[._](up|down)' $rtorrent_rc | tr ._=, ' ' | cut -f3 -d\" \" | sort | uniq)\"\necho\necho \"CURRENT THROTTLE SETTINGS\"\nfor throttle in $throttles; do\necho -e \"  $throttle\\t\" \\\n\"U: $(rtxmlrpc to_kb $(rtxmlrpc throttle.up.rate $throttle)) /\" \\\n\"$(rtxmlrpc to_kb $(rtxmlrpc throttle.up.max $throttle | sed 's/^-1$/0/')) KiB/s\\t\" \\\n\"D: $(rtxmlrpc to_kb $(rtxmlrpc throttle.down.rate $throttle)) /\" \\\n\"$(rtxmlrpc to_kb $(rtxmlrpc throttle.down.max $throttle | sed 's/^-1$/0/')) KiB/s\"\ndone\nfi\nexit 2\nfi\nrate=$(( $1 * $unit ))\n# Set chosen bandwidth\nif $down; then\nif test $(rtxmlrpc throttle.down.max $throttle_name) -ne $rate; then\nrtxmlrpc -q throttle.down $throttle_name $(( $rate / 1024 ))\necho \"Throttle '$throttle_name' download rate changed to\" \\\n\"$(( $(rtxmlrpc throttle.down.max $throttle_name) / 1024 )) KiB/s\"\nfi\nelse\nif test $(rtxmlrpc throttle.up.max $throttle_name) -ne $rate; then\nrtxmlrpc -q throttle.up $throttle_name $(( $rate / 1024 ))\necho \"Throttle '$throttle_name' upload rate changed to\" \\\n\"$(( $(rtxmlrpc throttle.up.max $throttle_name) / 1024 )) KiB/s\"\nfi\nfi\n</code></pre>"},{"location":"advanced/#global-throttling-when-other-computers-are-up","title":"Global throttling when other computers are up","text":"<p>If you want to be loved by your house-mates, try this:</p> <pre><code>#! /bin/bash\n# Throttle bittorrent when certain hosts are up\n#\n# CONFIGURATION\n#\nhosts_to_check=\"${1:-mom dad}\"\nfull_up=62\nfull_down=620\nnice_up=42\nnice_down=123\nunit=1024 # KiB/s\n#\n# HERE BE DRAGONS!\n#\n# Check if any prioritized hosts are up\nup=$(( $full_up * $unit ))\ndown=$(( $full_down * $unit ))\nhosts=\"\"\nfor host in $hosts_to_check; do\nif ping -c1 $host &gt;/dev/null 2&gt;&amp;1; then\nup=$(( $nice_up * $unit ))\ndown=$(( $nice_down * $unit ))\nhosts=\"$hosts $host\"\nfi\ndone\nreason=\"at full throttle\"\ntest -z \"$hosts\" || reason=\"for$hosts\"\n# Set chosen bandwidth\nif test $(rtxmlrpc throttle.global_up.max_rate) -ne $up; then\necho \"Setting upload rate to $(( $up / 1024 )) KiB/s $reason\"\nrtxmlrpc -q throttle.global_up.max_rate.set_kb $(( $up / 1024 ))\nfi\nif test $(rtxmlrpc throttle.global_down.max_rate) -ne $down; then\necho \"Setting download rate to $(( $down / 1024 )) KiB/s $reason\"\nrtxmlrpc -q throttle.global_down.max_rate.set_kb $(( $down / 1024 ))\nfi\n</code></pre> <p>Add it to your crontab and run it every few minutes.</p>"},{"location":"advanced/#throttling-rtorrent-for-a-limited-time","title":"Throttling rTorrent for a limited time","text":"<p>If you want to slow down rTorrent to use your available bandwidth on foreground tasks like browsing, but usually forget to return the throttle settings back to normal, then you can use the provided <code>rt-backseat</code> script. It will register a job via <code>at</code>, so that command must be installed on the machine for it to work. The default throttle speed and timeout can be set at the top of the script. <pre><code>#!/bin/bash\n# Throttle rTorrent for a certain amount of time\n#\n# CONFIGURATION\n#\ntimeout=\"now + 10 minutes\" # default timeout\nthrottled=42 # throttled speed\nunit=1024 # unit on command line, default KiB/s\nqueue=r\n#\n# HERE BE DRAGONS!\n#\nset -e\nset +x\ncase \"$1\" in\n-h | --help)\necho &gt;&amp;2 \"Usage: $0 [\u00abspeed\u00bb [\u00abtimespec\u00bb]]\"\nexit 1\n;;\n*) : ;;\nesac\nif test -n \"$(echo \"$1\" | tr -d 0-9)\"; then\necho &gt;&amp;2 \"ERROR: Non-numeric speed\"\nexit 1\nfi\nif test -n \"$1\"; then\nthrottled=\"$1\"\nshift\nfi\nthrottled=$(( throttled * unit ))\nif test -n \"$1\"; then\ntimeout=\"$*\"\nfi\nif test -n \"$(atq -q $queue)\"; then\n# If there are jobs pending, run 1st one now, and then delete them\nat -c \"$(atq -q $queue | cut -f1 | head -n1)\" | /bin/sh\natrm \"$(atq -q $queue | cut -f1)\"\nfi\ncurrent=$(rtxmlrpc throttle.global_down.max_rate)\n# Schedule new job to reset rate, and then throttle it\nresult=$(at -q $queue \"$timeout\" &lt;&lt;EOF 2&gt;&amp;1\nrtxmlrpc -q throttle.global_down.max_rate.set '' $current\nEOF\n) || :\nif [[ $result =~ .*(error|arbled).* ]]; then\necho &gt;&amp;2 \"ERROR: $result\"\nexit 1\nfi\necho \"$result\" | sed -re \"s~warning: commands will be executed using /bin/sh~~\"\nrtxmlrpc -q throttle.global_down.max_rate.set '' $throttled\necho \"Speed throttled to $(( throttled / 1024 )) KiB/s,\" \\\n     \"back to $(( current / 1024 )) KiB/s at $timeout.\"\n</code></pre></p>"},{"location":"changing-announce/","title":"Changing announce URLs","text":"<p>Many solutions will have you use <code>sed</code> or some other core Linux utility to do a find and replace.  While this usually works, it can very easily cause corruption.</p>"},{"location":"changing-announce/#using-chtor","title":"Using <code>chtor</code>","text":"<p>This method requires rTorrent to be shut down first, but completely removes the old announce:</p> <pre><code># Shut down rTorrent\n# Backing up the session directory is recommended: tar czvf rtorrent-session-$(date -Imin).tar.gz \"$(rtxmlrpc session.path)\"\ncd \"$(rtxmlrpc session.path)\"\nchtor --reannounce \"https://example.com/announce/new\" *.torrent --dry-run --diff # Dry-run the changes\nchtor --reannounce \"https://example.com/announce/new\" *.torrent                  # Run for real\nlstor  __hash__,announce *.torrent | grep example.com                            # Confirm the new URL is in place\n# Start up rTorrent\n</code></pre> <p>Note</p> <p>By default, <code>--reannounce</code> will only change the torrent file if the current announce's domain or alias matches the new one.  If you use <code>--reannounce-all</code> to change all torrents, it will also change the <code>info.x_cross_seed</code> key, unless <code>--no-cross-seed</code> is also provided</p>"},{"location":"changing-announce/#using-rtcontrol","title":"Using <code>rtcontrol</code>","text":"<p>The advantage of this method is that it doesn't require a restart of rTorrent, but instead disables the old trackers and inserts the new URL directly into the item:</p> <pre><code>rtcontrol \"tracker=http://example.com/announce/old\" \\\n--exec 't.multicall=0,t.disable= ; d.tracker.insert=0,\"https://example.com/announce/new\" ; d.save_full_session='\nrtcontrol \"tracker=https://example.com/announce/new\" # View torrents with the new announce\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The configuration file for pyrosimple is lives in <code>$HOME/.config/pyrosimple/config.toml</code>. If you've never used TOML files before, it's worth taking a quick look at the TOML documentation, but basically each section starts with a <code>[SECTION_NAME]</code> followed by keys and values.</p> <p>Here is a basic example of what your file could look like: <pre><code>rtorrent_rc = \"~/.rtorrent.rc\"\nfast_query = 1\n[FORMATS]\naction = '{{now|iso}} {{action}}\\t {{d.name}} {{d.alias}}'\n[ALIASES]\nUbuntu = [\"ubuntu.com\"]\n</code></pre></p> <p>If you'd like to use a file other than the default, use the <code>PYRO_CONF</code> environment variable: <pre><code>PYRO_CONF=/tmp/config.toml rtxmlrpc system.hostname\n</code></pre> Similar environment variables can be used to override individual parts of the configuration file: <pre><code>PYRO_RTORRENT_RC=/etc/rtorrent/rtorrent.rc PYRO_FAST_QUERY=0 rtcontrol //\n</code></pre> The equivalent environment variable will be shown in parentheses next to the config name below for reference.</p>"},{"location":"configuration/#reference","title":"Reference","text":""},{"location":"configuration/#top-level-section","title":"Top-level section","text":"<p>These entries in at the top of the file without a section name contain the most basic configuration settings for pyrosimple.</p>"},{"location":"configuration/#rtorrent_rc-pyro_rtorrent_rc","title":"<code>rtorrent_rc</code> (<code>PYRO_RTORRENT_RC</code>)","text":"<p>Defaults to <code>~/.rtorrent.rc</code>.</p> <p>This tells pyrosimple where to look for the rTorrent config file. It's mainly needed in order to automatically figure out where the SCGI port/file is listening, but may have other uses in the future.</p>"},{"location":"configuration/#scgi_url-pyro_scgi_url","title":"<code>scgi_url</code> (<code>PYRO_SCGI_URL</code>)","text":"<p>Defaults to being unset.</p> <p>If you'd prefer to manually set the SCGI URL, you can use this value to do so. When unset, pyrosimple will use the <code>rtorrent_rc</code> settings to automatically figure it out, but will raise an error if it's unable to find any hints.</p>"},{"location":"configuration/#sort_fields-pyro_sort_fields","title":"<code>sort_fields</code> (<code>PYRO_SORT_FIELDS</code>)","text":"<p>Defaults to <code>name,hash</code>.</p> <p>Sets the default sort order for output in <code>rtcontrol</code>.</p>"},{"location":"configuration/#mktor_ignore","title":"<code>mktor_ignore</code>","text":"<p>Defaults to <code>[\"core\", \"CVS\", \".*\", \"*~\", \"*.swp\", \"*.tmp\", \"*.bak\", \"[Tt]humbs.db\", \"[Dd]esktop.ini\", \"ehthumbs_vista.db\"]</code></p> <p>This allows overriding the list of temporary/hidden files <code>mktor</code> will ignore when creating torrents.</p>"},{"location":"configuration/#fast_query-pyro_fast_query","title":"<code>fast_query</code> (<code>PYRO_FAST_QUERY</code>)","text":"<p>Defaults to <code>0</code> (disabled).</p> <p>See query optimization for more information.</p>"},{"location":"configuration/#safety_checks_enabled-pyro_safety_checks_enabled","title":"<code>safety_checks_enabled</code> (<code>PYRO_SAFETY_CHECKS_ENABLED</code>)","text":"<p>Defaults to <code>True</code>.</p> <p>Several safety checks exist to provide more useful error message in cases such as missing methods/fields. In most cases this should have no impact other than an extra call to rtorrent's <code>system.listMethods</code>, but disabling these checks may be useful if you'd like to speed up command runs.</p>"},{"location":"configuration/#item_cache_expiration-pyro_item_cache_expiration","title":"<code>item_cache_expiration</code> (<code>PYRO_ITEM_CACHE_EXPIRATION</code>)","text":"<p>Defaults to <code>5.0</code>.</p> <p>The number of seconds to keep cached information for each item. The default aims to strike reasonable balance between reducing RPC calls while avoiding stale data.  <code>0</code> makes the process cache all information forever, while <code>-1</code> disables the cache entirely.</p>"},{"location":"configuration/#torque","title":"TORQUE","text":"<p>This section is reserved for <code>pyrotorque</code>. See its user guide for more information.</p>"},{"location":"configuration/#formats","title":"FORMATS","text":"<p>Allows defining Jinja2 templates for use with <code>rtcontrol</code>.</p> <p>Example: <pre><code>[FORMATS]\ndefault = '{%set ESC = \"\\x1B\" %}{%if d.down &gt; 0%}{{ESC+\"[1m\"}}{%endif%}{%if d.is_open%}O{%else%} {%endif%}{%if d.is_active%}A{%else%} {%endif%}{%if not d.is_complete%}{{ESC+\"[36m\"}}{{ \"{:&gt;3}\".format(d.done | round | int) }}{{ESC+\"[0m\"}}{%else%}  D{%endif%} {{\"{:&gt;10}\".format(d.size | filesizeformat(True))}} {%if d.message%}{{ESC+\"[31m\"}}{%endif%} {{d.alias.rjust(3)}}{{ESC+\"[0m\"}} {%if d.down &gt; 0%}{{ESC+\"[1m\"}}{%endif%}{{d.name}}{{ESC+\"[0m\"}}'\nfilelist = '{% for f in d.files%}{{d.realpath}}{% if d.is_multi_file %}/{{f.path}}{% endif %}{% if loop.index != loop.length %}\\n{% endif %}{% endfor %}'\naction = '{{now|iso}} {{action}}\\t {{d.name}} {{d.alias}}'\n</code></pre></p> <pre><code>rtcontrol is_completed=yes -o filelist\n</code></pre> <p>Note that any names defined here will override field names in the <code>-o</code> simple format, so make sure there are no conflicts.</p>"},{"location":"configuration/#aliases","title":"ALIASES","text":"<pre><code># Example with some common trackers\n[ALIASES]\nPBT     = [\"tracker.publicbt.com\", \"http://tracker.publicbt.com:80/announce\",\n\"udp://tracker.publicbt.com:80/announce\"]\nPDT     = [\"http://files2.publicdomaintorrents.com/bt/announce.php\"]\nArchOrg = [\"http://bt1.archive.org:6969/announce\",\n\"http://bt2.archive.org:6969/announce\"]\nOBT     = [\"http://tracker.openbittorrent.com:80/announce\",\n\"udp://tracker.openbittorrent.com:80/announce\"]\nDebian  = [\"http://bttracker.debian.org:6969/announce\"]\nLinux   = [\"http://linuxtracker.org:2710/\"]\n</code></pre> <p>This section allows for setting any number of tracker aliases for use with <code>rtcontrol</code>'s \"alias\" field, and when creating torrents with <code>mktor</code>.</p> <p>Note</p> <p><code>rtcontrol</code> will cache alias information inside rTorrent custom keys in order to speed up commands. To clear and then repopulate the cache, run the following commands:</p> <pre><code>rtcontrol --custom memo_alias= // -o hash # Clear the `memo_alias` custom key\nrtcontrol // -o alias                     # Force rtcontrol to immediate refill the key\n</code></pre>"},{"location":"configuration/#connections","title":"CONNECTIONS","text":"<pre><code># Example\n[CONNECTIONS]\nlocal = \"~/rtorrent/.scgi_local\"\nremote_scgi = \"scgi://example.com:9000\"\nremote_https = \"https://example.com/RPC2\"\n</code></pre> <p><code>rtmlxrpc</code>, <code>rtcontrol</code> and <code>pyrotorque</code> accept a <code>-U</code>/<code>--url</code> flag to provide the <code>scgi_url</code> directly when working with remote machines: <pre><code>rtxmlrpc -U \"~/rtorrent/.scgi_local\" system.hostname\n</code></pre></p> <p>Once defined, the short name can be used instead: <pre><code>rtxmlrpc -U local system.hostname\n</code></pre></p>"},{"location":"conky/","title":"Integrate with Conky","text":"<p>You can use <code>rtcontrol</code>'s templating features to easily integrate rTorrent in <code>conky</code>, a well-known desktop system monitor for Linux.</p> <ol> <li>Ensure the rtorstat template is installed in your templates directory (<code>~/.config/pyrosimple/templates/</code>)</li> <li>Integrate the example conky.rc into your local conky config.</li> <li>Start conky</li> </ol> <p>You should see rTorrent statistics showing up in your conky display after a brief delay. You can modify the <code>rtcontrol</code> command in <code>conky.rc</code> to control which individual torrents are displayed.</p>"},{"location":"custom-code/","title":"Custom Code","text":"<p><code>pyrosimple</code> offers a couple ways to extend its functionality if you know a little Python.</p>"},{"location":"custom-code/#custom-fields","title":"Custom fields","text":"<p>The <code>config.py</code> script can be used to add custom logic to your setup. The most common use for this file is adding custom fields.</p> <p>To add user-defined fields you can put code describing them into your <code>~/.config/pyrosimple/config.py</code> file. You can then use your custom field just like any built-in one, e.g. issue a command like <code>rtcontrol --from-view incomplete \\* -qco partial_done,name</code> (see below examples). They're also listed when you call <code>rtcontrol --help-fields</code>.</p> <p>Here's an example of adding a simple custom field:</p> <p>config.py<pre><code>from pyrosimple.torrent import engine\ndef _custom_fields():\nfrom pyrosimple.torrent import engine\nfrom pyrosimple.util import fmt, matching\n# Add a single field, which is matched like a number,\n# and accessed by performing a single RPC call.\nyield engine.ConstantField(\nint, # The type of the field, supported types are: int, str, set, bool, list, untyped\n\"piece_size\", # Name of the field\n\"Piece size for the item\", # The description for --help\nmatcher=matching.FloatFilter, # The filter type to use when matching the field, see pyrosimple.util.matching for a list of filters\naccessor=lambda o: o.rpc_call(\"d.size_chunks\"), # How to actually access the method. `o` is a pyrosimple.torrent.RtorrentItem\nrequires=[\"d.size_chunks\"], # Optional, but great speeds any rtcontrol commands by allowing prefetching\n)\n# Insert any other custom fields here\n# Register our custom fields to the proxy\nfor field in _custom_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre> <pre><code>rtcontrol // -o piece_size\n</code></pre></p>"},{"location":"custom-code/#examples","title":"Examples","text":"<p>You can see how the built-in fields are defined in torrent/engine.py if you want to see more complete examples.</p>"},{"location":"custom-code/#tracker-info","title":"Tracker info","text":"<p>These allow you to see the number of downloaders, seeders and leechers on items, provided the tracker supports announce scrapes.</p> <p>By default rTorrent only does a single scrape on restart or when an item is first added, which is why these fields aren't available by default. You'll need to set up your configuration as described in the rTorrent github wiki in order to see up-to-date values for these fields.</p> <pre><code>from pyrosimple.torrent import engine\ndef _custom_fields():\nfrom pyrosimple.torrent import engine\nfrom pyrosimple.util import fmt, matching\ndef get_tracker_field(obj, name, aggregator=sum):\n\"Get an aggregated tracker field.\"\nreturn aggregator(\n[t[0] for t in obj.rpc_call(\"t.multicall\", [\"\", f\"t.{name}=\"])]\n)\nyield engine.DynamicField(\nint,\n\"downloaders\",\n\"number of completed downloads\",\nmatcher=matching.FloatFilter,\naccessor=lambda o: get_tracker_field(o, \"scrape_downloaded\"),\nrequires=[\"t.multicall=,t.scrape_downloaded=\"],\n)\nyield engine.DynamicField(\nint,\n\"seeds\",\n\"number of seeds\",\nmatcher=matching.FloatFilter,\naccessor=lambda o: get_tracker_field(o, \"scrape_complete\"),\nrequires=[\"t.multicall=,t.scrape_complete=\"],\n)\nyield engine.DynamicField(\nint,\n\"leeches\",\n\"number of leeches\",\nmatcher=matching.FloatFilter,\naccessor=lambda o: get_tracker_field(o, \"scrape_incomplete\"),\nrequires=[\"t.multicall=,t.scrape_incomplete=\"],\n)\nyield engine.DynamicField(\nengine.untyped,\n\"lastscraped\",\n\"time of last scrape\",\nmatcher=matching.TimeFilter,\naccessor=lambda o: get_tracker_field(o, \"scrape_time_last\", max),\nformatter=lambda dt: fmt.human_duration(float(dt), precision=2, short=True),\nrequires=[\"t.multicall=,t.scrape_time_last=\"],\n)\n# Register our custom fields to the proxy\nfor field in _custom_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre>"},{"location":"custom-code/#peer-information","title":"Peer Information","text":"<p>Note that due to requiring a DNS lookup, <code>peers_hostname</code> may take a long time to display.</p> <pre><code>from pyrosimple.torrent import engine\ndef _custom_fields():\nimport socket\nfrom pyrosimple.torrent import engine\nfrom pyrosimple.util import fmt, matching\n# Add peer attributes not available by default\ndef get_peer_data(obj, name, aggregator=None):\n\"Get some peer data via a multicall.\"\naggregator = aggregator or (lambda _: _)\nresult = obj.rpc_call(\"p.multicall\", [\"\", \"p.%s=\" % name])\nreturn aggregator([i[0] for i in result])\nyield engine.OnDemandField(\nint,\n\"peers_connected\",\n\"number of connected peers\",\nmatcher=matching.FloatFilter,\nrequires=[\"d.peers_connected\"],\n)\nyield engine.DynamicField(\nset,\n\"peers_ip\",\n\"list of IP addresses for connected peers\",\nmatcher=matching.TaggedAsFilter,\nformatter=\", \".join,\naccessor=lambda o: set(get_peer_data(o, \"address\")),\nrequires=[\"p.multicall=,p.address=\"],\n)\nyield engine.DynamicField(\nset,\n\"peers_hostname\",\n\"list of hostnames for connected peers\",\nmatcher=matching.TaggedAsFilter,\nformatter=\", \".join,\naccessor=lambda o: set(\n[socket.gethostbyaddr(i)[0] for i in get_peer_data(o, \"address\")]\n),\nrequires=[\"p.multicall=,p.address=\"],\n)\nyield engine.DynamicField(\nset,\n\"peers_client\",\n\"Client/version for connected peers\",\nmatcher=matching.TaggedAsFilter,\nformatter=\", \".join,\naccessor=lambda o: set(get_peer_data(o, \"client_version\")),\nrequires=[\"p.multicall=,p.client_version=\"],\n)\n# Insert any other custom fields here\n# Register our custom fields to the proxy\nfor field in _custom_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre>"},{"location":"custom-code/#checking-for-specific-files","title":"Checking for specific files","text":"<pre><code>from pyrosimple.torrent import engine\ndef _custom_file_fields():\nimport fnmatch\nimport re\nfrom pyrosimple.torrent import engine\nfrom pyrosimple.util import fmt, matching\ndef has_glob(glob):\nregex = re.compile(fnmatch.translate(glob))  # Pre-compile regex for performance\n# Return a function containing the compiled regex to match against\ndef _has_glob_accessor(obj):\nreturn any([f for f in obj._get_files() if regex.match(f.path)])\nreturn _has_glob_accessor\nyield engine.DynamicField(\nengine.untyped,\n\"has_nfo\",\n\"does download have a .NFO file?\",\nmatcher=matching.BoolFilter,\naccessor=has_glob(\"*.nfo\"),\nformatter=lambda val: \"NFO\" if val else \"!DTA\" if val is None else \"----\",\n)\nyield engine.DynamicField(\nengine.untyped,\n\"has_thumb\",\n\"does download have a folder.jpg file?\",\nmatcher=matching.BoolFilter,\naccessor=has_glob(\"folder.jpg\"),\nformatter=lambda val: \"THMB\" if val else \"!DTA\" if val is None else \"----\",\n)\n# Register our custom fields to the proxy\nfor field in _custom_file_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre>"},{"location":"custom-code/#partial-downloads","title":"Partial Downloads","text":"<p>Note that the <code>partial_done</code> value can be a little lower than it actually should be, when chunks shared by different files are not yet complete; but it will eventually reach <code>100</code> when all selected chunks are downloaded in full.</p> <pre><code># Add file checkers\nfrom pyrosimple.torrent import engine\ndef _custom_partial_fields():\nfrom pyrosimple.torrent import engine\nfrom pyrosimple.util import fmt, matching\n# Fields for partial downloads\ndef partial_info(obj, name):\n\"Helper for partial download info\"\ntry:\nreturn obj._fields[name]\nexcept KeyError:\nf_attr = [\n\"completed_chunks\",\n\"size_chunks\",\n\"size_bytes\"\n\"range_first\",\n\"range_second\",\n\"priority\"\n]\nchunk_size = obj.rpc_call(\"d.chunk_size\")\nprev_chunk = -1\nsize, completed, chunks = 0, 0, 0\nfor f in obj._get_files(f_attr):\nif f.priority:  # selected?\nshared = int(f.range_first == prev_chunk)\nsize += f.size_bytes\ncompleted += f.completed_chunks - shared\nchunks += f.size_chunks - shared\nprev_chunk = f.range_second - 1\nobj._fields[\"partial_size\"] = size\nobj._fields[\"partial_missing\"] = (chunks - completed) * chunk_size\nobj._fields[\"partial_done\"] = 100.0 * completed / chunks if chunks else 0.0\nreturn obj._fields[name]\nyield engine.DynamicField(\nint,\n\"partial_size\",\n\"bytes selected for download\",\nmatcher=matching.ByteSizeFilter,\naccessor=lambda o: partial_info(o, \"partial_size\"),\n)\nyield engine.DynamicField(\nint,\n\"partial_missing\",\n\"bytes missing from selected chunks\",\nmatcher=matching.ByteSizeFilter,\naccessor=lambda o: partial_info(o, \"partial_missing\"),\n)\nyield engine.DynamicField(\nfloat,\n\"partial_done\",\n\"percent complete of selected chunks\",\nmatcher=matching.FloatFilter,\naccessor=lambda o: partial_info(o, \"partial_done\"),\n)\n# Register our custom fields to the proxy\nfor field in _custom_partial_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre>"},{"location":"custom-code/#checking-disk-space","title":"Checking disk space","text":"<p>This custom field also introduces the concept of using custom settings from <code>config.toml</code>. The code below uses <code>diskspace_threshold_mb</code> to decide if there's enough extra space on the disk (in addition to the amount the torrent uses) to consider it valid. If that setting isn't defined, it defaults to <code>500</code>.</p> <p>This field is particularly powerful when combined with the QueueManager, to prevent it from accidentally filling up a disk.</p> <pre><code>from pyrosimple.torrent import engine\ndef _custom_disk_fields():\nimport os\nimport pyrosimple\nfrom pyrosimple.torrent import engine\ndef has_room(obj):\ndiskspace_threshold_mb = int(\npyrosimple.config.settings.get(\"diskspace_threshold_mb\", 500)\n)\npath = Path(obj.path)\nif not path.exists():\npath = Path(path.parent)\nif path.exists():\nstats = os.statvfs(path)\nreturn stats.f_bavail * stats.f_frsize - int(\ndiskspace_threshold_mb\n) * 1024**2 &gt; obj.size * (1.0 - obj.done / 100.0)\nyield engine.DynamicField(\nengine.untyped,\n\"has_room\",\n\"check whether the download will fit on its target device\",\nmatcher=matching.BoolFilter,\naccessor=has_room,\nformatter=lambda val: \"OK\" if val else \"??\" if val is None else \"NO\",\n)\n# Register our custom fields to the proxy\nfor field in _custom_disk_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre>"},{"location":"custom-code/#rutorrent","title":"ruTorrent","text":"<p>Some ruTorrent plugins add additional custom fields: <pre><code>from pyrosimple.torrent import engine\ndef _custom_rutorrent_fields():\nfrom pyrosimple.torrent import engine\nyield engine.DynamicField(\nint,\n\"ru_seedingtime\",\n\"total seeding time after completion (ruTorrent variant)\",\nmatcher=matching.DurationFilter,\naccessor=lambda o: int(o.rpc_call(\"d.custom\",[\"seedingtime\"]) or \"0\")/1000,\nformatter=engine._fmt_duration,\nrequires=[\"d.custom=seedingtime\"]\n)\nyield engine.DynamicField(\nint,\n\"ru_addtime\",\n\"date added (ruTorrent variant)\",\nmatcher=matching.DurationFilter,\naccessor=lambda o: int(o.rpc_call(\"d.custom\",[\"addtime\"]) or \"0\")/1000,\nformatter=engine._fmt_duration,\nrequires=[\"d.custom=addtime\"]\n)\nfor field in _custom_rutorrent_fields():\nengine.TorrentProxy.add_field(field)\n</code></pre></p>"},{"location":"custom-code/#as-a-library","title":"As a library","text":"<p>The main interface has been designed to be deliberately simple if you wish to connect to rtorrent from within another Python program.</p> <pre><code>import pyrosimple\nengine = pyrosimple.connect()\nproxy = engine.open()\n</code></pre> <p>With this setup, <code>engine</code> can provide the same kind of high-level views and abstractions seen in <code>rtcontrol</code>.</p> <pre><code>engine.log(\"Hello world!\") # Prints to console of rtorrent\nprint([item.done for item in engine.view(\"incomplete\")]) # List the done percentage for torrents in the incomplete view\n</code></pre> <p>While <code>proxy</code> allows for low-level direct RPC calls, just like <code>rtxmlrpc</code>.</p> <pre><code>print(proxy.system.hostname())\nprint(proxy.d.multicall2('', 'main', 'd.hash='))\n</code></pre> <p>If you want to skip the auto-detection of rtorrent's URL, simply pass in your own to <code>connect()</code>.</p> <pre><code>engine = pyrosimple.connect(\"scgi://localhost:9000\")\n</code></pre> <p>See the <code>examples</code> directory for some useful python scripts.</p>"},{"location":"experimental/","title":"Experimental Features","text":""},{"location":"experimental/#query-optimization","title":"Query optimization","text":"<p>Requirements</p> <p>rTorrent must support the <code>d.multicall.filtered</code> method, which requires vanilla version 0.9.8+, or rTorrent-PS 1.1+.</p> <p>If your rTorrent supports <code>d.multicall.filtered</code>, rtcontrol can take advantage of it to return results faster. The option is controlled by the <code>-Q</code> flag in rtcontrol, or <code>fast_query</code> in the configuration file.</p> <p>Level <code>1</code> is less aggressive and safe by definition (i.e. produces correct results in all cases, unless there's a bug), while <code>-Q2</code> is highly experimental and in some circumstances likely produces results that are too small or empty.</p> <p>Optimization works by giving a pre-filter condition to rTorrent, to reduce the overhead involved in sending items over XMLRPC and processing them, only to be then discarded in the <code>rtcontrol</code> filter machinery.</p> <p>This goal of reducing the number of items sent to <code>rtcontrol</code> is best achieved if you put a highly selective condition first in a series of conditions. For cron-type jobs, this can often be achieved by looking at recent items only \u2013 older items should already be processed by previous runs. Even a very lenient window like \u201clast week\u201d drastically reduces items that need to be processed.</p> <pre><code>$ rtcontrol loaded=-6w is_ignored=0 -o- -v -Q0\nDEBUG:pyrosimple.util.rpc:method 'd.multicall2', params ('', 'default', 'd.custom=tm_loaded', 'd.hash=', 'd.ignore_commands=', 'd.name=')\nDEBUG:pyrosimple.torrent.rtorrent.RtorrentEngine:Got 23771 items with 4 attributes from 'localhost:415' [&lt;xmlrpc.client._Method object at 0x7ff59c348d30&gt;]\nDEBUG:pyrosimple.util.rpc:method 'view.size', params ('', 'default')\nINFO:pyrosimple.scripts.rtcontrol.RtorrentControl:Filtered 627 out of 23771 torrents.\nDEBUG:pyrosimple.scripts.rtcontrol.RtorrentControl:RPC stats: &lt;RTorrentProxy via json for scgi://localhost:7000?rpc=json&gt;\nINFO:pyrosimple.scripts.rtcontrol.RtorrentControl:Total time: 1.404 seconds.\n$ rtcontrol loaded=-6w is_ignored=0 -o- -v -Q1\nINFO:pyrosimple.torrent.rtorrent.RtorrentEngine:!!! pre-filter: greater=value=$d.custom=tm_loaded,value=1652724506\nDEBUG:pyrosimple.util.rpc:method 'd.multicall.filtered', params ('', 'default', 'greater=value=$d.custom=tm_loaded,value=1652724506', 'd.custom=tm_loaded', 'd.hash=', 'd.ignore_commands=', 'd.name=')\nDEBUG:pyrosimple.torrent.rtorrent.RtorrentEngine:Got 636 items with 4 attributes from 'localhost:415' [&lt;xmlrpc.client._Method object at 0x7f7f03428dc0&gt;]\nDEBUG:pyrosimple.util.rpc:method 'view.size', params ('', 'default')\nINFO:pyrosimple.scripts.rtcontrol.RtorrentControl:Filtered 627 out of 23771 torrents.\nDEBUG:pyrosimple.scripts.rtcontrol.RtorrentControl:RPC stats: &lt;RTorrentProxy via json for scgi://localhost:7000?rpc=json&gt;\nINFO:pyrosimple.scripts.rtcontrol.RtorrentControl:Total time: 0.672 seconds.\n</code></pre>"},{"location":"experimental/#connecting-to-multiple-clients","title":"Connecting to multiple clients","text":"<p>Warning</p> <p>This can cause strange behavior unless planned out. For instance, hashes are no longer enough to uniquely identify a torrent.</p> <p><code>rtxmlrpc</code> and <code>rtcontrol</code> support talking to multiple clients, by specifying a TOML list in the <code>CONNECTIONS</code> section: <pre><code>[CONNECTIONS]\nlocal=\"localhost:7000\"\nremote=\"remote.example.com:7000\"\nseedbox=\"https://username:password@seedbox.example.com\"\nall=[\"local\",\"seedbox\",\"remote\"]\n</code></pre> <pre><code>rtxmlrpc -U all system.hostname\n</code></pre></p>"},{"location":"experimental/#connecting-over-ssh","title":"Connecting over SSH","text":"<p>Requirements</p> <p><code>socat</code> is required to be installed on the remote server for this functionality. SSH authentication must also happen without any prompts, (i.e. through <code>authorized_keys</code> or a SSH agent that holds your password)</p> <pre><code># Via port\nrtxmlrpc -U scgi+ssh://example.com/TCP:0.0.0.0:7000 system.hostname\n# Via domain socket\nrtxmlrpc -U scgi+ssh://example.com/UNIX-CONNECT:/home/rtorrent/scgi.sock system.hostname\n</code></pre> <p>Since each command opens a new SSH connection, setting up the ControlPersist feature in <code>~/.ssh/config</code> is highly recommended.</p> <p>Example: <pre><code>Host *\n  ControlMaster auto\n  ControlPath ~/.ssh/sockets/%r@%h-%p\n  ControlPersist 600\n</code></pre></p>"},{"location":"experimental/#json-rpc","title":"JSON-RPC","text":"<p>Requirements</p> <p>Currently JSON-RPC is only supported by jesec-rtorrent: https://github.com/jesec/rtorrent. Pyrosimple supports this fork, but it is not maintained by the official rTorrent author (rakshasa).</p> <p>JSON-RPC is an light-weight RPC mechanism that is a nearly drop-in replaceable for XMLRPC, while having a much smaller message size and being faster to parse/produce.</p> <p>Pyrosimple handles converting commands between JSON and XML automatically, so enabling JSON-RPC for a given host is as simple as appending <code>?rpc=json</code> to the URL.</p> <pre><code>[CONNECTIONS]\nsocket_json_host = \"scgi://localhost:9988?rpc=json\"\nhttp_json_host = \"http://localhost:8080/RPC2?rpc=json\"\n</code></pre> <p>Note that there are some minor differences between command names between jesec-rtorrent and vanilla. <code>rtcontrol</code> will attempt to handle them automatically, while <code>rtxmlrpc</code> will not.</p> <p>Warning</p> <p>There is only one main limitation to the current JSON-RPC implementation: it cannot handle binary data types, which primarily effects the <code>load.*.raw</code> commands. jesec-rtorrent has made it so that the non-raw <code>load.*</code> commands can now accept base64-style URLs, which is intended to be a replacement.</p> <pre><code># XMLRPC\nrtxmlrpc load.raw_verbose '' &lt;base64 data&gt;\n# jesec-rtorrent's JSON-RPC\nrtxmlrpc load.verbose '' data:base64,&lt;base64 data&gt;\n</code></pre>"},{"location":"maintenance-tasks/","title":"General maintenance tasks","text":"<p>This is just to meant to be a section for useful commands that may not merit a full page.</p>"},{"location":"maintenance-tasks/#dumping-items-as-a-json-array","title":"Dumping items as a JSON array","text":"<p>If you want to access rTorrent item data in a machine readable form, you can feed the output of <code>rtcontrol</code> with the <code>--json</code> option into another script for further processing. By using <code>-o/--output</code>, you can also filter the fields being output. The following examples use the <code>jq</code> utility to validate and re-print the JSON data.</p> <pre><code># Process all known fields of the first torrent through jq\nrtcontrol --select 1 // | jq .\n# Process only the name and size\nrtcontrol -o name,size --select 1 // | jq .\n</code></pre>"},{"location":"maintenance-tasks/#flush-all-session-data-to-disk","title":"Flush all session data to disk","text":"<p>The <code>session.save</code> command saves the changing parts of the session status, that is the <code>*.torrent.libtorrent_resume</code> and <code>*.torrent.rtorrent files.</code> The copy of the original <code>*.torrent</code> metafile never changes and is thus left untouched.</p> <p>If you want to flush all the session data, call rtxmlrpc as follows:</p> <pre><code>rtxmlrpc session.save\n</code></pre> <p>This is best done before taking any backups, and after making any big changes. Note that by default <code>session.save</code> is run on 20 minutes schedule.</p>"},{"location":"maintenance-tasks/#move-data-for-selected-items-to-a-new-location","title":"Move data for selected items to a new location","text":"<p>Note</p> <p>The below commands can be replaced with the much simpler <code>--move-and-set</code> action:</p> <pre><code>rtcontrol alias=TRK realpath=\"$HOME/rtorrent/data\" --move-and-set \"$HOME/rtorrent/data/TRK\"\n</code></pre> <p>This sequence of commands will stop the selected items, move their data, flush rTorrent\u2019s metadata (session state), and finally starts everything again, followed by removing the items from the tagged view. The order matters and cannot be changed.</p> <pre><code>mkdir -p ~/rtorrent/data/TRK\nrtcontrol --to-view=trk-to-move alias=TRK realpath=$HOME/rtorrent/data is_complete=yes\nrtcontrol --from-view=trk-to-move // --yes \\\n  --stop \\\n  --spawn \"mv {{item.path}} $HOME/rtorrent/data/TRK\" \\\n  --exec \"directory.set=$HOME/rtorrent/data/TRK\" \\\n  --flush \\\n  --start\nrtcontrol --modify-view=trk-to-move --alter=remove realpath=$HOME/rtorrent/data/TRK\n</code></pre> <p>By changing the first <code>rtcontrol</code> command that populates the tagged view, you can change this to move data for any criteria you can think of.</p>"},{"location":"maintenance-tasks/#using-tags-to-control-item-processing","title":"Using tags to control item processing","text":"<p>By using the <code>--tag</code> command, it becomes easy to write scripts that will only run once against each item:</p> <pre><code>#!/usr/bin/env bash\nguard=\"handled\"\nrtcontrol --from-view=complete -q -o hash \"tagged=!$guard\" | \\\nwhile read hash; do\n# Do any processing\nrtxmlrpc d.hash \"$hash\"\n# Mark item as handled\nrtcontrol -q \"hash=$hash\" // --tag \"$guard\" --flush --yes\ndone\n</code></pre>"},{"location":"migrate/","title":"Migrating from pyroscope","text":""},{"location":"migrate/#configuration","title":"Configuration","text":"<ul> <li>The configuration file is located in a new location by default   (<code>~/.config/pyrosimple/config.toml</code>), and uses a new   format. Although the names have remained mostly the same, it is   recommended to manually copy settings over to the new format. See   the configuration guide for more information.</li> </ul>"},{"location":"migrate/#common-cli-options","title":"Common CLI options","text":"<ul> <li>Logging has been overhauled. <code>--cron</code> is now an alias for   <code>--quiet</code>. All logging goes to stderr.</li> <li><code>--config-dir</code> and <code>--config-file</code> have been removed. Set the   <code>PYRO_CONF</code> environment variable use a non-default config file.</li> <li><code>-D</code> has been removed. Use an environment variable to override   specific parts of the configuration instead.   <pre><code># Old\nrtcontrol -D rtorrent_rc=/etc/rtorrent/rtorrent.rc //\n# New\nPYRO_RTORRENT_RC=/etc/rtorrent/rtorrent.rc rtcontrol //\n</code></pre></li> </ul>"},{"location":"migrate/#rtxmlrpc","title":"<code>rtxmlrpc</code>","text":"<ul> <li><code>-x, --xml, -r, --repr</code> for XML output is no longer available. See   <code>--output &lt;format&gt;</code> for the new options.</li> <li>REPL   mode no longer triggers automatically with 0 arguments. To enter it,   use the <code>--repl</code> flag.</li> </ul>"},{"location":"migrate/#pyroadmin","title":"<code>pyroadmin</code>","text":"<p><code>pyroadmin</code> has been completely rebuilt. See <code>pyroadmin --help</code> for available utilities.</p>"},{"location":"migrate/#rtcontrol","title":"<code>rtcontrol</code>","text":"<ul> <li>Multiple actions flags are allowed, and the order in which they are   specified is the order in which they are executed. Previously, only   some combinations were allowed, and order did not matter. See <code>rtcontrol --help</code>   for the list of flags which are considered \"actions\".   <pre><code># Old\nrtcontrol // --stop &amp;&amp; \\\nrtcontrol // --custom foo=bar --flush &amp;&amp; \\\nrtcontrol // --custom baz=hkk --flush &amp;&amp; \\\nrtcontrol // --start\n# New\nrtcontrol // --stop --custom foo=bar --custom baz=hkk --flush --start\n</code></pre></li> <li>The <code>--anneal</code> flag has been removed. Use core Linux utilities   (e.g. <code>sort</code> and <code>uniq</code>) instead.</li> <li>Matching an empty string with a blank value (e.g. <code>message=</code>) will   no longer work as expected. Use an empty quoted string instead:   <pre><code># Old\nrtcontrol message=\nrtcontrol custom_1=\\!\n# New\nrtcontrol message=\\\"\\\"\nrtcontrol custom_1\\!=\\\"\\\"\nrtcontrol 'custom_1!=\"\"' # The entire filter can also be single quoted\n</code></pre></li> <li>String matching is now case-sensitive by default. To use   case-insensitive matching, use a regex with the <code>i</code> flag,   e.g. <code>name=/UbUnTu.*/i</code></li> <li>Relative times (e.g. <code>2d3m</code>) are now case-sensitive.</li> <li>Using <code>,</code> as an implicit <code>OR</code> no longer works. Use an explicit <code>OR</code> or a regex instead:   <pre><code># Old\nrtcontrol \"tracker=*ubuntu.com*,*archlinux.org*\"\n# New\nrtcontrol [ \"tracker=*ubuntu.com*\" OR \"tracker=*archlinux.org*\" ]\nrtcontrol \"tracker=/ubuntu.com|archlinux.org/\"\n</code></pre></li> </ul>"},{"location":"migrate/#templating","title":"Templating","text":"<ul> <li>Tempita has been replaced with   Jinja2. The   syntax is similar but not equivalent.   <pre><code># Old\nrtcontrol // -o '{{ if d.is_multi_file }}Multi-file path: {{ else }}Single file: {{ endif }}{{item.directory}}'\n# New\nrtcontrol // -o '{% if d.is_multi_file %}Multi-file path: {% else %}Single file: {% endif %}{{item.directory}}'\n</code></pre></li> <li>The string interpolation format style has been removed. Use the   Jinja2 template instead.   <pre><code># Old\nrtcontrol // -o '%(size.sz)s %(name)s'\n# New\nrtcontrol // -o '{{item.size|sz}} {{item.name}}'\n</code></pre></li> </ul>"},{"location":"migrate/#-exec","title":"<code>--exec</code>","text":"<ul> <li>All commands now use the full name. As such, the <code>:</code> signifier no   longer has any effect.   <pre><code># Old\nrtcontrol // --exec \"directory.set={{item.directory}}/{{item.custom_target_folder}}\"\nrtcontrol --exec \":event.download.finished=\" loaded=-10i done=100\n# New\nrtcontrol // --exec \"d.directory.set={{item.directory}}/{{item.custom_target_folder}}\"\nrtcontrol --exec \"event.download.finished=\" loaded=-10i done=100\n</code></pre></li> </ul>"},{"location":"migrate/#pyrotorque","title":"<code>pyrotorque</code>","text":"<ul> <li>All job handlers (the <code>handler =</code> setting in <code>config.toml</code>) have been moved under the <code>pyrosimple.job</code>   submodule. Specifically:<ul> <li><code>pyrocore.torrent.watch:QueueManager</code> -&gt; <code>pyrosimple.job.queue:QueueManager</code></li> <li><code>pyrocore.torrent.watch:TreeWatch</code> -&gt; <code>pyrosimple.job.watch:TreeWatch</code></li> <li><code>pyrocore.torrent.jobs:EngineStats</code> -&gt; <code>pyrosimple.job.metrics:EngineStats</code></li> </ul> </li> <li><code>TreeWatch</code>: The <code>queued</code> setting no longer has any effect. Use the   following configuration to achieve the same effect if desired:   <pre><code>[TORQUE.watch]\nhandler = \"pyrosimple.job.watch:TreeWatch\"\n# ...other settings...\ncmd_queue = \"d.priority.set=0\"\n</code></pre></li> </ul>"},{"location":"migrate/#chtor","title":"<code>chtor</code>","text":"<ul> <li>The <code>--no-ssl</code> flag has been removed. Manually specifying a non-SSL   announce still works as expected.</li> </ul>"},{"location":"migrate/#hashcheck","title":"<code>hashcheck</code>","text":"<ul> <li>This command has been removed. Use <code>lstor --check-data &lt;path&gt;</code> instead.</li> </ul>"},{"location":"migrate/#rtmv","title":"<code>rtmv</code>","text":"<ul> <li>This command has been removed. See this discussion   for more information, and a way to run the legacy conversion of the   command. Use <code>rtcontrol</code> with the <code>--symlink</code> flag instead.</li> </ul>"},{"location":"pyrotorque-jobs/","title":"Pyrotorque Jobs","text":""},{"location":"pyrotorque-jobs/#command","title":"Command","text":"<p>This job runs a single untemplated command. While this can also be done with straight cron, having it in pyrotorque allows keeping all rTorrent changes in one place. It also offers several improvements, such as per-second resolution.</p>"},{"location":"pyrotorque-jobs/#configuration","title":"Configuration","text":"<pre><code>[TORQUE.send_mail]\nhandler       = \"pyrosimple.job.action:Command\"\nargs          = \"echo 'pyrotorque is still running!' | mail -s 'pyrotorque check'\"\nshell         = true\nschedule      = \"hour=*\"\n</code></pre> <p>There are optional parameters <code>shell</code>, <code>cwd</code>, <code>timeout</code>, <code>check</code>, and <code>env</code>, all of which correspond to the parameters of <code>subprocess.run()</code></p>"},{"location":"pyrotorque-jobs/#item-command","title":"Item Command","text":"<p>This job is very similar to Command, but instead runs a templated command against all matching items.</p>"},{"location":"pyrotorque-jobs/#configuration_1","title":"Configuration","text":"<pre><code>[TORQUE.log_messaages]\nhandler       = \"pyrosimple.job.action:ItemCommand\"\nargs          = \"echo '{{item.hash}} has message {{item.message}}' &gt;&gt; /var/log/rtorrent/messages.log\"\nshell         = true\nschedule      = \"hour=*\"\nmatcher       = \"message=/.+/\"\nview          = \"default\"\n</code></pre> <p>There are optional parameters <code>shell</code>, <code>cwd</code>, <code>timeout</code>, <code>check</code>, and <code>env</code>, all of which correspond to the parameters of <code>subprocess.run()</code></p>"},{"location":"pyrotorque-jobs/#action-job","title":"Action Job","text":"<p>This is a simple job, intended to allow access to (almost) the same actions as <code>rtcontrol</code>.</p>"},{"location":"pyrotorque-jobs/#configuration_2","title":"Configuration","text":"<p>Example of stopping completed torrents after they reach a &gt;5 ratio:</p> <pre><code>[TORQUE.stop_well_seeded]\nhandler       = \"pyrosimple.job.action:Action\"\nschedule      = \"hour=*\"\nmatcher       = \"is_ignored=no ratio&gt;5.0\"\nview          = \"complete\"\naction        = \"stop\"\n</code></pre> <p>Arguments:</p> <ul> <li><code>action</code>: The action to perform. See <code>rtcontrol --help</code> for a list   of actions.</li> <li><code>view</code>: The rTorrent view to query</li> <li><code>matcher</code>: The query to use when listing torrents</li> </ul>"},{"location":"pyrotorque-jobs/#queue-manager","title":"Queue Manager","text":""},{"location":"pyrotorque-jobs/#configuration_3","title":"Configuration","text":"<p>The following is a minimal <code>config.toml</code> configuration example, only changing a few values from the defaults to demonstrate key features:</p> <pre><code>[TORQUE.queue]\nhandler = \"pyrosimple.job.queue:QueueManager\"\nschedule = \"minute=*\"\nsort = \"-prio,loaded,name\"\nmatcher = \"is_open=no tagged=torqued is_ignored=no done=0 message=''\"\ndownloading_min = 1\ndownloading_max = 100\n</code></pre> <p>Having a minimal configuration with just your changes is recommended, so you get new defaults in later releases automatically.</p> <p>Arguments:</p> <ul> <li><code>matcher</code>/<code>startable</code>   The query to use to determine which torrents are valid candidates to   be started. Defaults to <code>is_complete=no is_ignored=no is_open=no   message=\"\" done=0</code>.</li> <li><code>sort</code>/<code>sort_fields</code>   Determines the order in which torrents are started. Defaults to   <code>name,hash</code>.</li> <li><code>start_at_once</code>   The maximum number of items to start during a single run. May be   overridden by the <code>downloading_min</code> settings. Defaults to <code>1</code>.</li> <li><code>downloading</code>   The query used to determine the number of actively downloading   torrents. Defaults to <code>is_active=1 is_complete=0</code></li> <li><code>downloading_min</code>   If the number of actively downloading torrents is less than this   number, the job will ignore <code>start_at_once</code> to get to this   number. Defaults to <code>0</code> (meaning <code>start_at_once</code> will always be   honored).</li> <li><code>downloading_max</code>   If the number of actively downloading torrents is greater than this   number, pyrotorque will not start any items. Defaults to <code>20</code>.</li> <li><code>intermission</code>   If any items are started, pyrotorque will wait this many seconds   before attempting to start another. This is helpful to avoid   potentially starting too many items too quickly. Defaults to <code>120</code>.</li> <li><code>max_downloading_traffic</code>   If set, this setting will skip starting torrents when the torrents   in <code>downloading</code> exceed this value.</li> <li><code>log_to_client</code>   Can be set to <code>False</code> to avoid logging messages in rTorrent whenever   a torrent is started. Defaults to <code>True</code>.</li> </ul>"},{"location":"pyrotorque-jobs/#explanation","title":"Explanation","text":"<p>In the above example for the <code>queue</code> job, <code>downloading_max</code> counts started-but-incomplete items including those that ignore commands. Only if there are fewer of these items in the client than that number, a new item will be started. This is the queue's length and thus the most important parameter.</p> <p>The queue never stops any items, i.e. <code>downloading_max</code> is not enforced and you can manually start more items than that if you want to.  That is also the reason items that should be under queue control must be loaded in 'normal' mode, i.e. stopped.</p> <p>Other queue parameters are the minimum number of items in 'downloading' state named <code>downloading_min</code>, which trumps <code>start_at_once</code>, the maximum number of items to start in one run of the job. Both default to <code>1</code>. Since the default schedule is <code>second=*/15</code>, that means at most one item would be started every 15 seconds.</p> <p>But that default is changed using the following two lines:</p> <pre><code>schedule          = \"second=*/5\"\nintermission      = 60\n</code></pre> <p>This makes the queue manager check more often whether there is something startable, but prevents it from starting the next batch of items when the last start was less than <code>intermission</code> seconds ago.</p> <p>The <code>startable</code> condition (repeated below for reference) prevents ignored items, ones having a non-empty message, and those with the lowest priority from being started. Note that tree watch sets the priority of items loaded in 'normal' mode to zero -- that <code>prio&gt;0</code> condition then excludes them from being started automatically some time later, until you press <code>+</code> to increase that priority. You can also delay not-yet-started items using the <code>-</code> key until the item has a priority of zero (a/k/a <code>off</code>).</p> <pre><code>startable = '''\n        is_ignored=0 message= prio&gt;0\n        [ prio&gt;2 OR [ NOT [ traits=audio kind_25=jpg,png,tif,bmp ] ] ]\n'''\n</code></pre> <p>This sample condition also adds the extra hurdle that audio downloads that don't stay below a 25% threshold regarding contained images are not started automatically. Unless you raise the priority to 3 (<code>high</code>) using the <code>+</code> key, then they're fair game for the queue. Go do all that with a plain rTorrent watch dir, in one line of configuration.</p> <p>The parameter <code>sort_fields</code> is used to determinate in what order startable items are handled. By default, higher priority items are started first, and age is used within each priority class.</p> <p>Above, it was mentioned <code>downloading_max</code> counts started-but-incomplete items. The exact definition of that classification can be changed using the <code>downloading</code> condition. A given condition is always extended with <code>is_active=1 is_complete=0</code>, i.e. the started-but-incomplete requirement.</p> <pre><code>downloading = \"[ prio&gt;1 [ down&gt;3 OR started&lt;2 ] ]\"\n</code></pre> <p>In plain English, this example says we only count items that have a normal or high priority, and transfer data or were started in the last 2 minutes. The priority check means you can 'hide' started items from the queue by setting them to <code>low</code>, e.g. because they're awfully slow and prevent your full bandwidth from being used.</p> <p>The second part automatically ignores stalled items unless just started.  This prevents disk trashing when a big item is still creating its files and thus has no data transfer -- it looks stalled, but we do not want yet another item to be started and increasing disk I/O even more, so the manager sees those idle but young items as occupying a slot in the queue.</p>"},{"location":"pyrotorque-jobs/#tree-watch","title":"Tree Watch","text":"<p>This job is for loading torrents into rTorrent. While the native tools work well enough for simply loading torrents, this job allows for additional features like conditional logic and invalid file handling.</p> <p>Note that this job uses inotify, which is much lighter-weight but has the potential to miss files. See the <code>check_unhandled</code> argument for a way to counter this issue.</p>"},{"location":"pyrotorque-jobs/#configuration_4","title":"Configuration","text":"<pre><code>[TORQUE.watch]\nhandler = \"pyrocore.job.watch:TreeWatch\"\nschedule = \"second=*/5\"\npath = \"/var/torrents/watch\"\nstarted = false\ncheck_unhandled = true\nremove_already_added = true\ncmd_label = \"\"\"\n{% if 'TV' in flags %}d.custom1.set=TV{% endif %}\n\"\"\"\n</code></pre> <p>Arguments:</p> <ul> <li><code>path</code>: The path to watch for new files. Multiple paths can be   separate with <code>:</code>. Note that the watch is recursive.</li> <li><code>started</code>: Controls whether new items are automatically started   after adding</li> <li><code>check_unhandled</code>: If true, the job will try to find and update any   file it may have missed on each <code>schedule</code>. This will also catch any   files that were added while pyrotorque wasn't running</li> <li><code>remove_already_added</code>: If true, pyrotorque will remove files if the   hash already exists in the client. This is mainly useful to prevent   errors and files from building up if files are accidentally added to   the directory twice.</li> <li><code>cmd_*</code>: Any argument starting with this prefix is treated as a   custom command that will be run when the torrent is loaded. As seen   in the example, this can be a fully-templated string, with some   fields being auto-created by the job itself.</li> <li><code>preload_fields</code>: After loading the torrent, this setting can be   used to potentially preload other fields, so that expensive   calculations (e.g. for <code>kind</code>) can happen early</li> </ul>"},{"location":"pyrotorque-jobs/#explanation_1","title":"Explanation","text":"<p>As mentioned in <code>QueueManager</code>, commands configured to be executed during item loading can be templates. This can be used to support all sorts of tricks, the most common ones are explained here, including fully dynamic completion moving. If the following explanation of the inner workings is too technical and nerdy for you, skip to the tree watch examples section below, and just adapt one of the prepared use cases to your setup.</p> <p>So how does this work? When a <code>.torrent</code> file is notified for loading via <code>inotify</code>, it's parsed and contained data is put into variables that can be used in the command templates. In order to get an idea what variables are available, you can combine the dry-run and debug modes.</p> <p>Consider this example:</p> <pre><code>$ cd /var/torrent/watch\n$ date &gt;example.dat\n$ mktor -q example.dat http://tracker.example.com/\n$ python -m pyrosimple.job.watch\n2022-11-25 11:21:47,588  INFO job:: Building template variables for '/var/torrent/watch/example.torrent'\n2022-11-25 11:21:47,597  INFO job:: Available variables: {'commands': [],\n 'filetype': '.dat',\n 'flags': {'example.torrent', 'example', 'var', 'torrent', 'watch'},\n 'info_hash': '96336C9C3A1D8EC99C02FF79115476DDD4474A7A',\n 'info_name': 'example.dat',\n 'pathname': '/var/torrent/watch/example.torrent',\n 'rel_path': 'example.torrent',\n 'tracker_alias': 'example.com',\n 'watch_path': {'/var/torrent/watch/'}}\n</code></pre> <p>Things to take note of:</p> <ol> <li> <p>All kinds of information is made available, like the     torrent's info hash and the tracker alias; thus you can write     conditional templates based on tracker, or use the tracker name in     a completion path.</p> </li> <li> <p>For certain types of downloads, <code>traits</code> provides parsed     information to build specific target paths, e.g. for the     <code>Pioneer.One.S01E06.720p.x264-VODO</code> TV episode, you'll get this:</p> <pre><code>label='tv/mkv'\ntraits=Bunch(aspect=None, codec='x264', episode='06', extension=None, format='720p',\ngroup='VODO', kind='tv', pattern='Normal TV Episodes', release=None,\nrelease_tags=None, season='01', show='Pioneer.One', sound=None, title=None)\n</code></pre> </li> </ol>"},{"location":"pyrotorque-jobs/#examples","title":"Examples","text":""},{"location":"pyrotorque-jobs/#completion-moving","title":"Completion Moving","text":"<p>Since the templating namespace automatically includes the path of a loaded <code>.torrent</code> file relative to the watch root (in <code>relpath</code>, see above example namespace output and the config example further down), you can set the \\\"move on completion\\\" target using that value.</p> <pre><code>cmd_target    = {# set target path\n#}d.custom.set=targetdir,/var/torrent/done/{{label}}/{{relpath}}\n</code></pre> <p>Note that this still needs a typical completion event handler that takes the custom variable that is set, and moves the data based on its value.</p>"},{"location":"pyrotorque-jobs/#tree-watch-with-sorting","title":"Tree Watch with Sorting","text":"<p>This example adds a second job for a <code>sorted</code> tree that directly saves the data into a path based on the loaded metafile's location.</p> <pre><code># Tree watch with location\njob.watch-sorted.handler        = pyrocore.torrent.watch:TreeWatch\njob.watch-sorted.schedule       = hour=*\njob.watch-sorted.active         = True\njob.watch-sorted.load_mode      = normal\njob.watch-sorted.queued         = True\njob.watch-sorted.path           = /var/torrent/sorted/watch\njob.watch-sorted.cmd.setdir     = {{# set download path\n}}{{if '/music/' in pathname}}{{# add metafile basename to path\n}}d.directory_base.set=\"/var/torrent/sorted/{{relpath}}/{{pathname|h.pathname}}\"{{#\n}}{{elif traits.kind == 'tv'}}{{# store TV content into separate show folders\n}}d.directory.set=\"/var/torrent/sorted/{{relpath}}/{{traits.get('show', '_UNKNOWN').replace('.',' ').title()}}\"{{#\n}}{{else}}{{# just use the relative metafile location\n}}d.directory.set=\"/var/torrent/sorted/{{relpath}}\"{{#\n}}{{endif}}\n</code></pre> <p>Change the values in the second block to suit your needs. As given, an item loaded from <code>\u2026/sorted/watch/movies/*.torrent</code> would end up in the <code>\u2026/sorted/movies</code> directory (with the filename coming from inside the metafile as usual), and it won't start by itself.</p> <p>Also, paths containing <code>music</code> use the metafile's basename as the data directory, and metafiles recognized as TV content get separated into show directories.</p>"},{"location":"pyrotorque-tutorial/","title":"Pyrotorque Tutorial","text":"<p>Currently the existing pyrotorque documentation ranges from vague to very detailed. This will hopefully provide a more pleasant introduction to the tool. For this tutorial, we're going to focus on a few basic use cases:</p> <ul> <li>Load torrent files from <code>/var/rtorrent/watch/</code> without starting them</li> <li>Use QueueManager to start torrents in a controlled manner</li> <li>Move the data of completed torrents to <code>/var/rtorrent/done/</code></li> </ul> <p>All the configuration provided below should be placed under the <code>[TORQUE]</code> section in <code>~/.config/pyrosimple/config.toml</code>. The full configuration is provided at the end for reference.</p>"},{"location":"pyrotorque-tutorial/#load-torrents","title":"Load torrents","text":"<p>To start with, we'll use the <code>TreeWatch</code> class to load torrents. This is very similar to the native <code>directory.watch.added</code> command, but has several advantages, such as being able to pick up missing torrents.</p> <p>The following configuration allows us to load all torrents under <code>/var/rtorrent/watch/</code> and any of its subdirectories. The torrents are loaded without being started, and every 15 minutes (as per <code>schedule</code>) the directory is checked for any torrents that haven't been loaded (in case they were added while pyrotorque or rTorrent wasn't running). It also executes two user-defined commands via <code>cmd_custom_fields</code> to set the <code>loaded_by</code> and <code>tracker_alias</code> fields. Finally, <code>cmd_download_directory</code> sets the target directory to <code>/var/rtorrent/downloading/</code>.</p> <pre><code>[TORQUE.load]\nhandler = \"pyrocore.job.watch:TreeWatch\"\nschedule = \"minute=*/15\"\ncheck_unhandled = true\npath = \"/var/rtorrent/watch/\"\nstarted = false\ncmd_set_custom_fields = \"\"\"\n    d.custom.set=loaded_by,pyrotorque\n    d.custom.set=tracker_alias,{{tracker_alias}}\n\"\"\"\ncmd_download_directory = \"d.directory.set=/var/rtorrent/downloading/\"\n</code></pre>"},{"location":"pyrotorque-tutorial/#start-torrents","title":"Start torrents","text":"<p>Next we'll have pyrotorque start the loaded torrents in an orderly fashion. This configuration tells pyrotorque to start torrents one at at time every 5 minutes, up to a maximum of 20. However, the maximum of 20 is deciding by only considering torrents that are actively downloading data, so that the queue doesn't get stuck on dead torrents. The <code>matcher</code> value below is set to only start torrents which have the <code>loaded_by</code> custom field set to <code>pyrotorque</code> (among other filters), so that it doesn't interfere with other programs (e.g. Radarr). It will also use <code>sort_fields</code> so that higher priority torrents are started first.</p> <pre><code>[TORQUE.start]\nhandler         = \"pyrocore.job.queue:QueueManager\"\nschedule        = \"minute=*/5\"\nmatcher         = \"custom_loaded_by=pyrotorque is_ignored=no prio&gt;0\"\nsort_fields     = \"-prio,loaded,name\"\nstart_at_once   = 1\ndownloading     = \"is_active=yes is_complete=no down&gt;0\"\ndownloading_max = 20\n</code></pre>"},{"location":"pyrotorque-tutorial/#move-torrents","title":"Move torrents","text":"<p>Every 10 minutes, this job will check for finished torrents and move them. Ignored torrents and any actively transferring data are filtered out.</p> <pre><code>[TORQUE.move_complete]\nhandler       = \"pyrosimple.job.move_path:PathMover\"\nschedule      = \"minute=*/10\"\nmatcher       = \"is_ignored=no is_complete=yes path=/var/rtorrent/downloading/* xfer=0\"\ntarget        = \"/var/rtorrent/done\"\n</code></pre>"},{"location":"pyrotorque-tutorial/#full-configtoml","title":"Full <code>config.toml</code>","text":"<pre><code>[TORQUE]\n[TORQUE.load]\nhandler = \"pyrocore.job.watch:TreeWatch\"\nschedule = \"minute=*/15\"\ncheck_unhandled = true\npath = \"/var/rtorrent/watch/\"\nstarted = false\ncmd_set_custom_fields = \"\"\"\n    d.custom.set=loaded_by,pyrotorque\n    d.custom.set=tracker_alias,{{tracker_alias}}\n\"\"\"\ncmd_download_directory = \"d.directory.set=/var/rtorrent/downloading/\"\n[TORQUE.start]\nhandler         = \"pyrocore.job.queue:QueueManager\"\nschedule        = \"minute=*/5\"\nmatcher         = \"custom_loaded_by=pyrotorque is_ignored=no prio&gt;0\"\nsort_fields     = \"-prio,loaded,name\"\nstart_at_once   = 1\ndownloading     = \"is_active=yes is_complete=no down&gt;0\"\ndownloading_max = 20\n[TORQUE.move_complete]\nhandler       = \"pyrosimple.job.move_path:PathMover\"\nschedule      = \"minute=*/10\"\nmatcher       = \"is_ignored=no is_complete=yes path=/var/rtorrent/downloading/* xfer=0\"\ntarget        = \"/var/rtorrent/done\"\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>The main goal of this document is to get you comfortable with using pyrosimple to interact with rTorrent and torrent files. None of the commands here will make any changes to your system and are intended to be a gentle introduction to the many capabilities available.</p>"},{"location":"quickstart/#setup","title":"Setup","text":"<p>Install pyrosimple:</p> <pre><code>pip install pyrosimple\n# pip install 'pyrosimple[torque]' # Optional dependencies for using pyrotorque\n</code></pre> <p>With pyrosimple installed and rTorrent running, let's create an basic configuration and see if the connection to rTorrent can be auto-detected:</p> <pre><code>pyroadmin config --create-config\npyroadmin config --check &amp;&amp; echo \"All good!\"\n</code></pre> <p>If the command doesn't show any errors, then pyrosimple has automatically figured out how to talk with rTorrent. Neat!</p> <p>If not, see Configuration for instructions on how to set up your config file, and come back once the command succeeds.</p>"},{"location":"quickstart/#interacting-with-rtorrent","title":"Interacting with rTorrent","text":"<p>Let's start with something simple: <code>rtxmlrpc</code> is a command for interacting with rTorrent's low-level API. Let's run some more commands to get an idea of what it can do. None of these commands will change anything, they'll just return information.</p> <pre><code># Get rTorrent's version\nrtxmlrpc system.client_version\n# Get the current download rate (in bytes/sec)\nrtxmlrpc throttle.global_down.rate\n# Get the name of all torrents in the 'main' view\nrtxmlrpc d.multicall2 '' main d.name=\n</code></pre> <p>That's all very nice, but it'd be even nicer if there was a command to make dealing with all the torrents easier than running all these RPC commands. That's where <code>rtcontrol</code> comes into play. It allows for scripting and outputting against torrents without needing to learn rTorrent's RPC API directly. Try out the following commands:</p> <pre><code># Get all torrents in the 'main' view\nrtcontrol //\n# Get the hash of torrents in the 'main' view\nrtcontrol // -o hash\n# Get the size and name of completed torrents\nrtcontrol is_complete=yes -o size.sz,name\n# Get the upload, download and name of any not-ingnored active torrents\nrtcontrol is_ignored=no xfer=+0 -o up.sz,down.sz,name\n</code></pre> <p>Note</p> <p>The string <code>//</code> in the first two commands is an empty regex. If you don't know what that means, don't worry, it's just an easy way to get all torrents.</p> <p><code>rtcontrol</code> lets us filter on different fields, and optionally pick which fields will be output. The many different fields that are available can be shown with <code>rtcontrol --help-fields</code>.  In addition to simply displaying torrents, we can also run commands that will make things change.</p> <p>For the sake of this tutorial, all of the commands below have <code>--dry-run</code> at the end to make sure nothing is changed. If you'd like to try running the commands for real, simply remove that flag.</p> <pre><code># Start all torrents\nrtcontrol // --start --dry-run\n# Set a custom field on all active torrents\nrtcontrol xfer=+0 --custom test=hello --dry-run\n# Hash check all un-ignored completed torrents\nrtcontrol is_ignored=no is_complete=yes --hash-check --dry-run\n</code></pre>"},{"location":"quickstart/#working-with-torrents","title":"Working with torrents","text":"<p>In addition to rTorrent, pyrosimple can also work with .torrent files directly. The commands <code>mktor</code>, <code>lstor</code> and <code>chtor</code> can make, list, and modify files, respectively.</p> <p>Let's try creating an example torrent from an example file with the (fake) tracker <code>http://example.com</code>.</p> <pre><code>date &gt; example.txt\nmktor -o example.torrent example.txt http://example.com\n</code></pre> <p>Now we can check our newly created torrent:</p> <pre><code>lstor example.torrent\n</code></pre> <p>It looks pretty good, but maybe there should be a comment added to it.</p> <pre><code>chtor --comment 'Hello world!' example.torrent\n# View the changed file\nlstor example.torrent\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<ul> <li>All of the commands listed above have many more capabilities than what     is shown here. Refer to their respective User Guide pages for a     full explanation of what each tool can do.<ul> <li><code>rtcontrol</code> in particular has many uses, as seen in     rtcontrol's usage page</li> </ul> </li> <li>See Advanced Usage for more advanced examples     of the things that can be done with pyrosimple.</li> </ul>"},{"location":"rtorrent-config/","title":"rTorrent configuration","text":"<p>While no rTorrent configuration is strictly required, some fields will only work correctly with configuration, and commands can be assigned to rTorrent functions for easy access.</p> <p>Note</p> <p>If you already have an existing <code>rtorrent-ps</code>/<code>rtorrent-ps-ch</code> configuration set up, you shouldn't need to make any changes to it.</p> <p>Tip</p> <p>To skip all the explanations and quickly generate a full config, run the following command:</p> <pre><code>pyroadmin -v config --create-rtorrent-rc\n</code></pre> <p>The full-featured <code>rtorrent.rc</code> used above is provided here. The configuration provided by pyrocore should still be compatible as well.</p>"},{"location":"rtorrent-config/#rtorrent-installation","title":"rTorrent installation","text":"<p>Any version of rTorrent &gt;=0.9.6 is supported, however the efficiency improvements and JSON-RPC support that have been added to jesec/rtorrent make it highly recommended. If you prefer a nice TUI (among other quality-of-life fixes), consider rTorrent-PS as well.</p>"},{"location":"rtorrent-config/#fields","title":"Fields","text":""},{"location":"rtorrent-config/#timestamps","title":"Timestamps","text":"<p>This config records timestamps for use by the <code>loaded</code>, <code>started</code>, <code>completed</code>, <code>last_xfer</code> and <code>last_active</code> fields.</p> <pre><code># loaded\nmethod.set_key = event.download.inserted_new, !time_stamp,\\\n\"d.custom.set=tm_loaded,$cat=$system.time= ; d.save_resume=\"\n# started\nmethod.insert = pyro._tm_started.now, simple|private,\\\n\"d.custom.set=tm_started,$cat=$system.time= ; d.save_resume=\"\nmethod.set_key = event.download.resumed, !time_stamp,\\\n\"branch=d.custom=tm_started,false=,pyro._tm_started.now=\"\n# completed\nmethod.insert = pyro._tm_completed.now, simple|private,\\\n\"d.custom.set=tm_completed,$cat=$system.time= ; d.save_resume=\"\nmethod.set_key = event.download.finished, !time_stamp,\\\n\"pyro._tm_completed.now=\"\nmethod.set_key = event.download.hash_done, !time_stamp,\\\n\"branch=\\\"and={d.complete=,not=$d.custom=tm_completed}\\\", pyro._tm_completed.now=\"\n# active - This section is *not* needed for variants that implement `d.timestamp.last_active` natively (i.e. jesec/rtorrent)\nmethod.insert = d.timestamp.last_active, simple, \"if=$d.peers_connected=,$cat=$system.time=,$d.custom=last_active\"\nmethod.insert = d.timestamp.last_active.update, simple|private,\\\n\"d.custom.set=last_active,$cat=$system.time= ; branch=argument.0=,d.save_resume=\"\nschedule2 = pyro_update_last_active, 24, 42,\\\n\"d.multicall2=started,\\\"branch=$d.peers_connected=,d.timestamp.last_active.update=\\\"\"\nmethod.set_key = event.download.resumed, !last_active,\\\n\"branch=\\\"or={d.peers_connected=,not=$d.custom=last_active}\\\", d.timestamp.last_active.update=1\"\nmethod.set_key = event.download.finished, !last_active, \"d.timestamp.last_active.update=1\"\n# last_xfer\nmethod.insert.value = pyro.last_xfer.min_rate, 5000\nmethod.insert = pyro._last_xfer_check_min_rate, simple|private,\\\n\"greater=argument.0=,pyro.last_xfer.min_rate=\"\nmethod.insert = pyro._last_xfer_update, simple|private,\\\n\"d.custom.set=last_xfer,$cat=$system.time= ; branch=argument.0=,d.save_resume=\"\nmethod.insert = d.last_xfer.is_active, simple,\\\n\"or={pyro._last_xfer_check_min_rate=$d.up.rate=,pyro._last_xfer_check_min_rate=$d.down.rate=}\"\nmethod.insert = d.timestamp.last_xfer, simple, \"if=$d.last_xfer.is_active=,$cat=$system.time=,$d.custom=last_xfer\"\nschedule2 = pyro_update_last_xfer, 33, 17,\\\n\"d.multicall2=active,\\\"branch=$d.last_xfer.is_active=,pyro._last_xfer_update=\\\"\"\n</code></pre> <p>The following command can be used to backfill the data where possible: <pre><code># Remove the --dry-run to actually backfill the data.\npyroadmin backfill --dry-run\n</code></pre> This is safe to run multiple times if needed.</p>"},{"location":"rtorrent-config/#ui","title":"UI","text":""},{"location":"rtorrent-config/#searching","title":"Searching","text":"<p>The following snippet allows for quick searching directly in the UI. The examples below can be modified to suit any searches you find yourself using often.</p> <pre><code># VIEW: Use rtcontrol filter (^X s=KEYWORD, ^X t=TRACKER, ^X f=\"FILTER\")\nmethod.insert = s,simple|private,\"execute.nothrow=rtcontrol,--detach,-qV,\\\"$cat=*,$argument.0=,*\\\"\"\nmethod.insert = t,simple|private,\"execute.nothrow=rtcontrol,--detach,-qV,\\\"$cat=\\\\\\\"alias=\\\\\\\",$argument.0=\\\"\"\nmethod.insert = f,simple|private,\"execute.nothrow=rtcontrol,--detach,-qV,$argument.0=\"\n</code></pre>"},{"location":"tips/","title":"Tip &amp; Tricks","text":""},{"location":"tips/#working-with-rutorrent","title":"Working with ruTorrent","text":"<p>pyrosimple and ruTorrent can be used at the same time with no issue. To view/filter on ruTorrent's labels, use the <code>custom_1</code> field:</p> <pre><code>rtcontrol custom_1=TV -o alias,name\n</code></pre> <p>For convience, the same value is available under the <code>label</code> field:</p> <pre><code>rtcontrol label=TV -o alias,name\n</code></pre>"},{"location":"tips/#repairing-stuck-items","title":"Repairing stuck items","text":"<p>Sometimes items will get stuck in a state where they are unable to start correctly, even after a hash check. Check that rTorrent has the correct access to the file first, and if so this command will reset all the file states and force another hash check. This is the same as pressing <code>^K^E^R</code> in the UI.</p> <pre><code>rtcontrol --exec 'd.stop= ; d.close= ; f.multicall=,f.set_create_queued=0,f.set_resize_queued=0 ; d.check_hash=' \\\n--from stopped // -/1 --yes\n</code></pre> <p>The above example only effect 1 torrent from the stopped view. After the hash check is complete and the torrent is working again, use <code>--start</code> to start it again.</p>"},{"location":"tips/#instance-statistics","title":"Instance statistics","text":"<pre><code>#!/bin/bash\necho -n rTorrent $(rtxmlrpc system.client_version)/$(rtxmlrpc system.library_version)\necho -n , up $(rtxmlrpc -q convert.elapsed_time '' $(ls -l --time-style '+%s' $SCGI_SOCKET | awk '{print $6}'))\necho \\ [$(rtcontrol -qo\"1 {{d.uploaded}} {{d.size}}\" \\* | \\\nawk '{ TOT += $1; UP += $2; SUM += $3} END { print TOT \" loaded; U: \" UP/1024/1024/1024 \" GiB; S: \" SUM/1024/1024/1024 }') GiB]\necho -n D: $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_down.total))\necho -n \\ @ $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_down.rate))/s\necho -n \\ of $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_down.max_rate))/s\necho -n , U: $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_up.total))\necho -n \\ @ $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_up.rate))/s\necho -n \\ of $(rtxmlrpc convert.xb '' $(rtxmlrpc throttle.global_up.max_rate))/s\necho\n</code></pre> <p>Note that this can also be implemented much more efficiently as a python script: <pre><code>#!/usr/bin/env python3\nimport pyrosimple\nengine = pyrosimple.connect()\nproxy = engine.open()\nprint(f\"rTorrent {proxy.system.client_version()}/{proxy.system.library_version()}\", end='')\nprint(f\", up {proxy.convert.elapsed_time('', str(proxy.startup_time()))}\", end='')\ncount = 0\nsize = 0\nuploaded = 0\nfor item in engine.view():\ncount += 1\nsize += item.size\nuploaded += item.uploaded\nprint(f\"[TOT {count}; U: {proxy.convert.xb('', str(uploaded))}; S {proxy.convert.xb('', str(size))}]\")\nprint(f\"D: {proxy.convert.xb('', str(proxy.throttle.global_down.total()))} \", end='')\nprint(f\"@ {proxy.convert.xb('', str(proxy.throttle.global_down.rate()))}/s \", end='')\nprint(f\"of {proxy.convert.xb('', str(proxy.throttle.global_down.max_rate()))}/s, \", end='')\nprint(f\"U: {proxy.convert.xb('', str(proxy.throttle.global_up.total()))} \", end='')\nprint(f\"@ {proxy.convert.xb('', str(proxy.throttle.global_up.rate()))}/s \", end='')\nprint(f\"of {proxy.convert.xb('', str(proxy.throttle.global_up.max_rate()))}/s\")\n</code></pre></p>"},{"location":"tips/#find-orphaned-files","title":"Find orphaned files","text":"<p>Since Jinja2 is more sandboxed than the original Tempita templating system, the <code>orphans.txt</code> template file from pyrocore no longer works. However, we can replicate the functionality with a little fancy scripting. The following command will list the orphan files along with their sizes:</p> <pre><code>target_dir=/mnt/test\ncomm -13 \\\n&lt;(rtcontrol -o filelist \"path=${target_dir}*\" | sort) \\\n&lt;(find \"$target_dir\" -type f | sort) \\\n| tr '\\n' '\\0' | xargs -0 du -hsc\n</code></pre> <p>To clean up the files (after ensuring the list is accurate!), we can just change the final command from <code>du</code> to <code>rm</code>. Note that this example uses <code>echo rm</code> to ensure nothing is deleted accidentally:</p> <pre><code>comm -13 \\\n&lt;(rtcontrol -o filelist \"path=${target_dir}*\" | sort) \\\n&lt;(find \"$target_dir\" -type f | sort) \\\n| tr '\\n' '\\0' | xargs -0 echo rm\n</code></pre>"},{"location":"tips/#dumping-items-as-a-json-array","title":"Dumping items as a JSON array","text":"<p>If you want to access rTorrent item data in machine readable form via rtcontrol, you can use its --json option and feed the output into another script parsing the JSON data for further processing.</p> <p>Here\u2019s an example:</p> <pre><code>$ rtcontrol --json -qo name,is_ghost,directory,fno ubuntu-22.04.iso\n[\n  {\n    \"directory\": \"/var/torrent/load/foo\",\n    \"fno\": 1,\n    \"is_ghost\": false,\n    \"name\": \"ubuntu-22.04.iso\"\n  }\n]\n</code></pre> <p>rtxmlrpc is also capable of producing JSON output: <pre><code>$ rtxmlrpc -o json d.multicall2 '' main d.name= d.directory= d.size_files=\n[[\"ubuntu-22.04.iso\", \"/var/torrent/load/foo\", 1]]\n</code></pre></p>"},{"location":"usage-pyrotorque/","title":"pyrotorque","text":"<p>Note</p> <p>pyrotorque requires additional dependencies. To install them, run <pre><code>pip install 'pyrosimple[torque]'\n</code></pre></p> <p>Tip</p> <p>See the pyrotorque tutorial for an introduction to how pyrotorque works by setting up a basic workflow.</p> <p>The <code>pyrotorque</code> command is a daemon that handles background jobs. At first, it was just a flexible torrent queue manager for starting items one at a time (thus the name <code>pyro-tor-que</code>), but it can now manage any job that does some background processing for rTorrent, including custom ones that you can add yourself.</p> <p>There are two primary jobs that can be run from pyrotorque:</p> <ul> <li>A tree watcher that reacts via <code>inotify</code> to load new files into   rTorrent as needed.  It functions very similarly to   <code>directory.watch.added</code>, but allows for more complex loading rules,   as well as recursive watching.</li> <li>A queue manager that handles starting torrents in a controlled   manner. This ensures that a system is not overloaded by starting too   many torrents at once. The job is compatible with torrents from both   the tree watcher and files loaded by <code>directory.watch.added</code> or a   <code>load</code> schedule.</li> </ul>"},{"location":"usage-pyrotorque/#configuration","title":"Configuration","text":"<p>The base pyrotorque configuration lives in <code>config.toml</code>, under the <code>[TORQUE._settings]</code> key. Here's an example:</p> <pre><code>[TORQUE._settings]\nautoreload = false # false by default\nlog_level = \"WARNING\" # \"WARNING\" by default\npid_file = \"/var/run/pyrotorque.pid\" # \"$XDG_RUNTIME_DIR/pyrotorque.pid\" or \"~/.pyrosimple/run/pyrotorque.pid\" by default\nlog_file = \"/var/log/pyrotorque.log\" # Disabled by default\n</code></pre>"},{"location":"usage-pyrotorque/#job-configuration","title":"Job Configuration","text":"<p>The job configuration lives in the same <code>config.toml</code> with everything else, in the <code>[TORQUE]</code> section. Under the section, there are settings for pyrotorque itself, and then sub-sections for the individual jobs.</p> <p>Example: <pre><code>[TORQUE]\n[TORQUE._settings]\nautoreload = true # false by default\n[TORQUE.stats]\nhandler = \"pyrocore.torrent.jobs:EngineStats\"\nschedule = \"minute=*\"\nactive = true\ndry_run = true\n[TORQUE.watch]\nhandler = \"pyrocore.torrent.watch:TreeWatch\"\nschedule = \"minute=*\"\nactive = true\ndry_run = true\npath = \"/tmp/watch\"\ncmd.test = \"d.custom=test\"\n[TORQUE.queue]\nhandler = \"pyrocore.torrent.watch:QueueManager\"\nschedule = \"hour=*\"\nactive = true\ndry_run = true\n</code></pre></p> <p>As seen in the example <code>stats</code> job, there are four main settings for a job:</p> <ul> <li><code>handler</code> defines what class will run. You shouldn't need to   understand what this means unless you're writing custom jobs, see   the handler reference below instead.</li> <li><code>schedule</code> tells pyrotorque when to trigger jobs. If you're familiar   with cron syntax, this is very similar, e.g. <code>minute=*</code> means run   once a minute. The underlying library, APScheduler, extends the   syntax with features like per-second resolution. Check out the   documentation   for details.</li> <li><code>active</code> provides an easy way to enable or disable jobs.</li> <li><code>dry_run</code> tells the job to not make any actual changes if it's <code>true</code>.</li> <li><code>scgi_url</code> allows overriding the target instance, and can accept aliases.</li> </ul> <p>Any other settings are job-specific. For detailed documentation on each job, see the reference documentation.</p>"},{"location":"usage-pyrotorque/#usage","title":"Usage","text":"<p>Once you have a configuration file, the easiest way to test your configuration is to try running the process in the foreground:</p> <pre><code># Also enforce dry_run mode and output info messages while we're testing things\npyrotorque --fg --dry-run -v\n</code></pre> <p>Alternatively, you can also test the individual jobs one run at a time: <pre><code>pyrotorque --run-once stats --dry-run --debug\n</code></pre></p> <p>Once you're satisfied, you can launch the process into the background by simply running <code>pyrotorque</code>. You can check the status, restart, or stop the daemon with <code>--status</code>, <code>--restart</code> and <code>--stop</code> respectively. Alternatively, see your distro's documentation for writing service files. Here is a bare-bones example for a systemd-based distro:</p> pyrotorque.service<pre><code>[Unit]\nDescription=Pyrotorque rtorrent daemon\nAfter=network-online.target rtorrent.service\nWants=rtorrent.service\n[Service]\nType=simple\nExecStart=pyrotorque --fg\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"usage-rtcontrol/","title":"rtcontrol","text":"<p><code>rtcontrol</code> is one of the most flexible tools in the pyrosimple arsenal, which also means it can become very complex very quickly.</p> <p><code>rtcontrol</code> maps rTorrent attributes to fields, which are a python-oriented way to represent the attributes. You can see the list of supported fields by running <code>rtcontrol --help-fields</code>.</p>"},{"location":"usage-rtcontrol/#filter-conditions","title":"Filter Conditions","text":"<p>In order for <code>rtcontrol</code> to do anything, it first needs a filter condition that will tell it which torrents it should perform work against. Filters take the form of a field, operator and value, which will look familiar if you've dealt with any kind of programming or scripting.</p> <pre><code>size&gt;8G\nloaded&lt;2d5h\nname=ubuntu-server-amd64-22.04.iso\n</code></pre> <p>If the field and operator are omitted, they are assumed to be <code>name</code> and <code>=</code> respectively. This means the following filters are exactly the same:</p> <pre><code>ubuntu-server-amd64-22.04.iso\nname=ubuntu-server-amd64-22.04.iso\n</code></pre> <p>If multiple filters are specified, torrents must match against all of them. The special keyword <code>OR</code> can be used to override that behavior, and change it so that only one of the filters have to match:</p> <pre><code>size&lt;=4G name!=ubuntu-server-amd64-22.04.iso\nname=/ubuntu/ OR name=/debian/\n</code></pre> <p><code>[</code> and <code>]</code> can be used to group filters, and <code>NOT</code> or <code>!</code> can be used to invert groups:</p> <pre><code>! [ size&gt;700m size&lt;=1400m ]\nname=arch-* OR [ alias=Ubuntu loaded&gt;1w ]\n</code></pre> <p>Note</p> <p>Since many characters like <code>!</code> or <code>&lt;</code> have special meanings in the shell, they will most likely need to be quoted or escaped when actually used on the command line.</p> <pre><code>rtcontrol 'size&gt;700m' 'size&lt;=1400m'\n</code></pre> <p>Entire queries can also be quoted without any problems:</p> <pre><code>rtcontrol 'size&gt;700m size&lt;=1400m'\n</code></pre> <p>Many fields allow for special parsing of the value to support more complicated filters:</p> <ul> <li>strings (e.g. <code>name</code>, <code>alias</code>)<ul> <li>By default, strings are matched using shell-style   wildcards. This   means that to search for a substring instead of an   exact match, you should use an expression like <code>*ubuntu*</code>.   Example: <code>arch-linux-*</code></li> <li>If the value starts and ends with <code>/</code>, the value is treated as a   regex,   which allows for more complex expressions than just   wildcards. Note that the whole string does not need to match;   use <code>^</code> and <code>$</code> to enforce that behavior.   Examples: <code>/.*/</code>, <code>/^ubuntu-.+-server-.*/</code></li> </ul> </li> <li>numbers (e.g. <code>size</code>, <code>xfer</code>)<ul> <li>Byte number fields like <code>size</code> allow for suffixes to denote the size.   Example: <code>5g</code>, <code>64m</code></li> </ul> </li> <li>time (e.g. <code>loaded</code>, <code>completed</code>)   Similar to bytes, time fields accept multiple shorthands for comparing time:<ul> <li>Time deltas in the form of <code>&lt;num&gt;&lt;unit&gt;[&lt;num&gt;&lt;unit&gt;...]</code>, where <code>unit</code> is a single letter to denote <code>y</code>ear, <code>M</code>onth, <code>w</code>eek, <code>d</code>day, <code>h</code>our, <code>m</code>inute or <code>s</code>second.   Examples: <code>3w22h</code>, <code>1y6M</code></li> <li>An exact date/time in a human-readable formate. Acceptable   formats for the date are <code>YYYY-MM-DD</code>, <code>MM/DD/YYYY</code>,   <code>DD.MM.YYYY</code>. To also include a <code>HH:MM</code> time, separate it from   the date with a space or a <code>T</code>.   Examples: <code>04/15/2021</code>, <code>2022-03-15T14:50</code></li> <li>An absolute timestamp in epoch time format.   Example: <code>1652289156</code></li> </ul> </li> <li>tags (e.g. <code>tagged</code>, <code>views</code>)<ul> <li>Tags are work similarly to strings, but they do not support   regexes, and use whitespace as delimiters. For example, if a   torrent has the tags <code>active archive new</code>, the values <code>n*</code> and   <code>archive</code> would both match.</li> </ul> </li> </ul> <p>There are also some special fields that are \"manifold\" fields. These aren't fields in of themselves, but will generate a field dynamically based on the prefix. As an example, the <code>rtcontrol -o d_name //</code> gives the exact same value as <code>rtcontrol -o name</code>, but without having to define the field directly. Instead, any field starting with <code>d_</code> is transformed into its dynamic <code>d.</code> equivalent. Besides <code>d_</code>, there are also manifolds for the prefixes <code>f_</code>, <code>p_</code>, <code>metafile_</code>, among others. See <code>rtcontrol --help-fields</code> for the full list.</p> <p>Warn</p> <p>Since manifold fields are generated dynamically, the type can't always be inferred correctly, which can cause unexpected behavior during filtering. Using the built-in fields is preferred, and custom fields may still be required for efficiency or proper filtering in some cases.</p>"},{"location":"usage-rtcontrol/#output","title":"Output","text":"<p>By default, rtcontrol will use a predefined output template that displays most relevant information, but allows for selecting specific fields with the <code>-o</code>/<code>--output-format</code> flag.</p> <p>The simplest way to use it is to simply specific a comma-separated list of fields:</p> <pre><code>rtcontrol // -o alias,size,path\n</code></pre> <p>If you want to override the default formatting, rtcontrol provides a set of specifiers for quick changes (see <code>rtcontrol --help-fields</code> for the list of available specifiers).</p> <pre><code># Same command as above, but modify the path and size output\nrtcontrol // -o alias,size.sz,path.pathbase\n</code></pre>"},{"location":"usage-rtcontrol/#jinja2","title":"Jinja2","text":"<p>For more complex output, the Jinja2 library can be used. It has support for much more complex formatting and logic than the simple CSV output. See the official Jinja2 documentation for everything it's capable of .</p> <pre><code>rtcontrol // -o '{{d.alias}}\\t{{d.size|filesizeformat(binary=True)}}\\t{{d.path|truncate(40)}}'\n</code></pre> <p>As your output templates get more complex, you can use the <code>TEMPLATES</code> section in the configuration to set predefined templates, rather than putting the whole string in the CLI every time. This is how the <code>default</code> and <code>action</code> templates are defined. See the configuration file for more info.</p>"},{"location":"usage-rtcontrol/#actions","title":"Actions","text":"<p>rtcontrol has many ways to effect torrent, including but not limited to:</p> <ul> <li><code>--start</code>/<code>--stop</code>/<code>--delete</code>: starting/stopping/remove torrents</li> <li><code>--cull</code>,<code>--purge</code>: remove torrents along with all or partial data</li> <li><code>--custom KEY=VALUE</code>: setting custom values</li> <li><code>--move</code>/<code>--move-and-set</code>: Move, and optionally set the directory   after the move (similar flags also exist to copy, symlink, and   hardlink)</li> <li><code>--call</code>/<code>--spawn</code>: call a OS command/shell</li> <li><code>-H</code>/<code>--hash-check</code>: trigger a hash check on torrents (equivalent to   pressing <code>^R</code> in the UI)</li> </ul> <p>See <code>rtcontrol --help</code> for a full list of actions. All action can be dry-run with the <code>-n</code>/<code>--dry-run</code> flag. Many of the more dangerous actions (e.g. <code>--cull</code>) will prompt before actually performing the action. However, if you wish to enable prompting for all action, the <code>-i</code>/<code>--interactive</code> will set that behavior for all commands. Alternatively, if you don't want any prompts at all, <code>--yes</code> will automatically confirm all prompts.</p> <p>When multiple actions are specified, rtcontrol will apply those actions to each item in sequence.</p>"},{"location":"usage-rtcontrol/#executing-commands","title":"Executing commands","text":"<p><code>rtcontrol</code> has two ways to execute OS commands:</p> <ul> <li><code>--spawn</code> creates a new process with the command:   <pre><code># Update the mtime on all session files\nrtcontrol --spawn 'touch {{item.metafile}}' //\n</code></pre></li> <li>If you need to use shell features (such as pipes or file   redirection) in the command, use <code>`--call</code> instead:   <pre><code># Append the name of completed items to a file\nrtcontrol --call 'echo {{item.name|shell}} &gt;&gt; /tmp/names.txt' is_complete=yes\n</code></pre> Most of the time <code>--spawn</code> will be enough, but <code>-call</code> exists as a handy shortcut.</li> </ul> <p>To call rTorrent's RPC, use the <code>--exec</code> flag: <pre><code># These two commands do the same thing: start all torrents\nrtxmlrpc d.multicall2 '' default d.start=\nrtcontrol // --exec 'd.start='\n</code></pre> Besides filtering, using rtcontrol instead of rtxmlrpc allows you to use formatting in the same manner as <code>--spawn</code>/<code>--call</code>: <pre><code># Set all incomplete downloads to a dedicated directory, based on hash\nrtcontrol is_active=no is_complete=no --exec 'd.directory_base.set=/tmp/downloads/{{item.hash}}'\n</code></pre></p>"},{"location":"usage-rtcontrol/#moving-data","title":"Moving data","text":"<p>Moving files around is a common operation when managing a client. Similar to how rtcontrol provides a safe way to delete torrents with <code>--cull</code>/<code>--purge</code>, there are also action flags for <code>--move</code>, <code>--copy</code>, <code>--symlink</code> and <code>--hardlink</code>. For convience, each flag also has a <code>*-and-set</code> conterpart, which will both perform the action and set the download directory to the torrent.</p> <p>Combine this with the ability to use templates for the move target, and you'll have a very powerful tool for managing data: <pre><code># Move completed torrents to a different directory\nrtcontrol path=/data/torrent/incomplete/\\* --from=complete --move-and-set='/data/torrent/complete/{{item.alias}}'\n# Use guessit to organize media automaticallar (requires guessit: `pip install guessit`)\nrtcontrol custom_organized\\!=true --copy=\"/data/media/{{item.guessit_title}} ({{item.guessit_year}})\" --custom=organized=true --flush\n</code></pre></p>"},{"location":"usage-rtcontrol/#examples","title":"Examples","text":"<ul> <li><code>rtcontrol '*HDTV*'</code>   Find anything with \"HDTV\" in its name.</li> <li><code>rtcontrol is_open=y is_active=n</code>   Find paused items.</li> <li><code>rtcontrol alias=foo --close</code>   Close all torrents from a specific tracker.</li> <li><code>rtcontrol -o size.sz // --summary</code>   Show the total size of all torrents.</li> <li><code>rtcontrol -o filelist path=/mnt/tmp/\\*</code>   List all files in rTorrent under a directory.</li> <li><code>rtcontrol --start is_complete=yes is_active=no is_open=no</code>   Start all completed but inactive torrents.</li> </ul>"},{"location":"usage-rtcontrol/#filter-examples","title":"Filter examples","text":"<ul> <li> <p><code>'*HDTV*'</code>:     Anything with \"HDTV\" in its name</p> </li> <li> <p><code>/s\\d+e\\d+/</code>:     Anything with typical TV episode numbering in its name (regex match)</p> </li> <li> <p><code>ratio=+1</code>:     All downloads seeded to at least 1:1</p> </li> <li> <p><code>xfer=+0</code>:     All active torrents (transferring data)</p> </li> <li> <p><code>up=+0</code> or <code>up\\&gt;0</code>:     All seeding torrents (uploading data)</p> </li> <li> <p><code>down=+0 down=-5k</code> or <code>down\\&gt;0 down\\&lt;=5k</code>:     Slow torrents (downloading, but with &lt; 5 KiB/s)</p> </li> <li> <p><code>down=0 is_complete=no is_open=yes</code>:     Stuck torrents</p> </li> <li> <p><code>size=+4g</code>:     Big stuff (DVD size or larger)</p> </li> <li> <p><code>is_complete=no</code>:     Incomplete downloads</p> </li> <li> <p><code>is_open=y is_active=n</code>:     Paused items</p> </li> <li> <p><code>is_ghost=yes</code>:     Torrents that have no data (were never started or lost their data)</p> </li> <li> <p><code>alias=obt</code>:     Torrents tracked by <code>openbittorrent.com</code> (see     configuration on how to add aliases for     trackers)</p> </li> <li> <p><code>ratio=+1 realpath\\!=/mnt/\\*</code>:     1:1 seeds not on a mounted path (i.e. likely on localhost)</p> </li> <li> <p><code>completed=+2w</code>:     Completed more than 2 weeks ago</p> </li> <li> <p><code>tagged=:</code> or <code>tagged=\\\"\\\"</code>:     Not tagged at all</p> </li> <li> <p><code>tagged!=:</code>:     Has at least one tag</p> </li> <li> <p><code>tagged=foo,bar</code>:     Tagged with \"foo\" or \"bar\" (since v0.3.5) \u2014 tags are white-space     separated lists of names in the field <code>custom_tags</code></p> </li> <li> <p><code>tagged=:highlander</code>:     Only tagged with \"highlander\" and nothing else</p> </li> <li> <p><code>kind=flac,mp3</code>:     Music downloads</p> </li> <li> <p><code>files=sample/\\*</code>:     Items with a top-level <code>sample</code> folder</p> </li> <li> <p><code>ratio=+2.5 OR seedtime=+1w</code>:   Items seeded to 5:2 or for more than a week</p> </li> <li> <p><code>alias=foo [ ratio=+2.5 OR seedtime=+7d ]</code>:   The same as above, but for one tracker only</p> </li> <li> <p><code>traits=avi traits=tv,movies</code>:   TV or movies in AVI containers</p> </li> <li> <p><code>custom_1!=?*</code>:   matches any torrent without a rutorrent label</p> </li> <li> <p><code>custom_1==*</code>:   matches any torrent with or without a rutorrent label</p> </li> </ul>"},{"location":"usage-rtxmlrpc/","title":"rtxmlrpc","text":"<p>Since rtxmlrpc is intended to interact directly with rTorrent, it is deliberately designed to be simple. However, there are a few useful features to be aware of.</p>"},{"location":"usage-rtxmlrpc/#typing","title":"Typing","text":"<p>Most of the time, strings are sufficient for dealing with rTorrent's commands, however sometimes you may need to coerce arguments to be a certain type.  Start arguments with <code>+</code> or <code>-</code> to indicate they're numbers (type i4 or i8).  Use <code>[1,2,...</code> for arrays. Use <code>@</code> to indicate binary data, which can be followed by a file path (e.g. <code>@/path/to/file</code>), a URL (https, http, ftp, and file are supported), or <code>@-</code> to read from stdin.</p> <p>Note</p> <p>Using the <code>@</code> syntax to load data from URLs requires the <code>requests</code> library to be installed: <pre><code>pip install requests\n</code></pre></p> <p>Examples: <pre><code># Force an integer\nrtxmlrpc throttle.max_downloads.div.set '' +100\n# Load data from stdin\necho 'Hello world!' | rtxmlrpc print '' @-\n# Load binary data from a URL\nrtxmlrpc load.raw '' @https://releases.ubuntu.com/22.04/ubuntu-22.04-live-server-amd64.iso.torrent\n</code></pre></p>"},{"location":"usage-rtxmlrpc/#running-as-import","title":"Running as import","text":"<p>It's also possible to run commands directly through rTorrent's command system, through the use of its <code>import</code> command.  By specifying the <code>-i</code>/<code>--as-import</code> flag, rtxmlrpc will write the command to a temporary file, and tell rTorrent to <code>import</code> it directly.</p> <p>Example <pre><code>rtxmlrpc --as-import 'print=\"Hello world!\"'\n# This is equivalent to:\n# $ echo 'print=\"Hello world!\"' &gt; /tmp/rtorrent-cmd\n# $ rtxmlrpc import '' /tmp/rtorrent-cmd\n# $ rm /tmp/rtorrent-cmd\n</code></pre></p>"},{"location":"usage-tor/","title":"mktor/lstor/chtor","text":"<p>The following tools are grouped together due to their similar functionality. They can create, view, and modify .torrent files respectively.</p>"},{"location":"usage-tor/#lstor","title":"lstor","text":"<p>lstor is used for displaying information about torrents. Without any flags, it shows a human-friendly summary of the torrent:</p> <pre><code>$ lstor ubuntu-22.04-desktop-amd64.iso.torrent\nNAME ubuntu-22.04-desktop-amd64.iso.torrent\nSIZE 3.4 GiB (13942 * 256.0 KiB + 142.0 KiB)\nMETA 272.7 KiB (pieces 272.3 KiB 99.9%)\nHASH 2C6B6858D61DA9543D4231A71DB4B1C9264B0685\nURL  https://torrent.ubuntu.com/announce\nPRV  NO (DHT/PEX enabled)\nTIME 2022-04-21 10:22:56\nBY   mktorrent 1.1\nREM  Ubuntu CD releases.ubuntu.com\n\nFILE LISTING\nubuntu-22.04-desktop-amd64.iso                                         3.4 GiB\n</code></pre> <p>However, you can also display the same information in JSON format with the <code>--raw</code> flag: <pre><code>lstor ubuntu-22.04-desktop-amd64.iso.torrent --raw\n</code></pre> <pre><code>{\n\"announce\": \"https://torrent.ubuntu.com/announce\",\n\"announce-list\": [\n[\n\"https://torrent.ubuntu.com/announce\"\n],\n[\n\"https://ipv6.torrent.ubuntu.com/announce\"\n]\n],\n\"comment\": \"Ubuntu CD releases.ubuntu.com\",\n\"created by\": \"mktorrent 1.1\",\n\"creation date\": 1650550976,\n\"info\": {\n\"length\": 3654957056,\n\"name\": \"ubuntu-22.04-desktop-amd64.iso\",\n\"piece length\": 262144,\n\"pieces\": \"&lt;13943 piece hashes&gt;\"\n}\n}\n</code></pre></p> <p>If you only need to extract a few fields, the <code>-o</code>/<code>--output</code> flag lets you specify which fields to show:</p> <pre><code>$ lstor -o info.name,__size__ ubuntu-22.04-desktop-amd64.iso.torrent\nubuntu-22.04-desktop-amd64.iso  3654957056\n</code></pre> <p>Note</p> <p><code>__size__</code> is a magic variable that tells <code>lstor</code> to sum the sizes of all files in the torrent. See <code>lstor --help</code> for all the supported magic variables.</p> <p>By default lstor will throw an error if the file isn't a valid .torrent file. However, if you wish to ignore those errors (to view a rTorrent session file, for instance), the <code>--raw</code> flag can be combined with <code>-V</code>/<code>--skip-validation</code>.</p> <p><code>lstor</code> can also hash check the torrent against real data by using the <code>-c &lt;path&gt;</code> flag.</p>"},{"location":"usage-tor/#mktor","title":"mktor","text":"<p>At its simplest, creating a torrent file requires only a path and an announce URL:</p> <pre><code>date &gt; date.txt\nmktor date.txt http://tracker.publicbt.com:80/announce\n</code></pre> <p>If you have aliases configured, you can use the alias in place of the URL.</p> <p>config.toml<pre><code>[ALIASES]\nPUB_BT = [\"http://tracker.publicbt.com:80/announce\"]\n</code></pre> <pre><code>mktor date.txt PUB_BT\n</code></pre></p>"},{"location":"usage-tor/#cross-seeding","title":"Cross-seeding","text":"<p>To avoid duplicating the same hash across private trackers, mktor has two mechanisms to add distinct data to the <code>info</code> dictionary:</p> <ul> <li><code>source</code> gets set to the tracker alias (if available), or the 2nd   level domain if not available</li> <li><code>x_cross_seed</code> gets set to an MD5 hash of the URL</li> </ul> <p>If you don't want one or both of these fields present, you can use the <code>-s</code>/<code>--set</code> flag to have them removed:</p> <pre><code>mktor --set info.source --set info.x_cross_seed date.txt http://tracker.publicbt.com:80/announce\n</code></pre>"},{"location":"usage-tor/#chtor","title":"chtor","text":"<p>If you have an existing .torrent file you'd like to change, whether created by <code>mktor</code> or an entirely different program, <code>chtor</code> is your friend.</p> <p>Warning</p> <p>Changing any fields in the <code>info</code> section of the data will change the torrent hash, which may have unintended consequences.</p> <p>The simplest way to change data is the <code>-s</code>/<code>--set</code> flag, which can add, change, or remove fields:</p> <pre><code>date &gt; date.txt\nmktor date.txt http://tracker.publicbt.com:80/announce\nlstor --raw date.torrent\nchtor --set \"last changed=$(date)\" date.torrent # Add \\\n--set \"created by=PyroSimple v2\" # Change \\\n--set \"creation date=\" # Remove\nlstor --raw date.torrent\n</code></pre> <p>There's also a similar flag to set fields with a regex:</p> <pre><code>chtor --regex \"created by/PyroSimple/PyroChanged/\" date.torrent\n</code></pre> <p>There are many other flags available to perform common operations, such as removing non-standard fields (<code>--clean</code>) or adding fast resume data (<code>--datapath &lt;DATA&gt;</code>).</p>"}]}